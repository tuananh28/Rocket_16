{"ast":null,"code":"import { forEach } from 'property-expr';\nvar trim = function trim(part) {\n  return part.substr(0, part.length - 1).substr(1);\n};\nexport function getIn(schema, path, value) {\n  var context = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : value;\n  var parent, lastPart, lastPartDebug; // root path: ''\n\n  if (!path) return {\n    parent: parent,\n    parentPath: path,\n    schema: schema\n  };\n  forEach(path, function (_part, isBracket, isArray) {\n    var part = isBracket ? trim(_part) : _part;\n    schema = schema.resolve({\n      context: context,\n      parent: parent,\n      value: value\n    });\n    if (schema.innerType) {\n      var idx = isArray ? parseInt(part, 10) : 0;\n      if (value && idx >= value.length) {\n        throw new Error(\"Yup.reach cannot resolve an array item at index: \".concat(_part, \", in the path: \").concat(path, \". \") + \"because there is no value at that index. \");\n      }\n      parent = value;\n      value = value && value[idx];\n      schema = schema.innerType;\n    } // sometimes the array index part of a path doesn't exist: \"nested.arr.child\"\n    // in these cases the current part is the next schema and should be processed\n    // in this iteration. For cases where the index signature is included this\n    // check will fail and we'll handle the `child` part on the next iteration like normal\n\n    if (!isArray) {\n      if (!schema.fields || !schema.fields[part]) throw new Error(\"The schema does not contain the path: \".concat(path, \". \") + \"(failed at: \".concat(lastPartDebug, \" which is a type: \\\"\").concat(schema._type, \"\\\")\"));\n      parent = value;\n      value = value && value[part];\n      schema = schema.fields[part];\n    }\n    lastPart = part;\n    lastPartDebug = isBracket ? '[' + _part + ']' : '.' + _part;\n  });\n  return {\n    schema: schema,\n    parent: parent,\n    parentPath: lastPart\n  };\n}\nvar reach = function reach(obj, path, value, context) {\n  return getIn(obj, path, value, context).schema;\n};\nexport default reach;","map":{"version":3,"names":["forEach","trim","part","substr","length","getIn","schema","path","value","context","arguments","undefined","parent","lastPart","lastPartDebug","parentPath","_part","isBracket","isArray","resolve","innerType","idx","parseInt","Error","concat","fields","_type","reach","obj"],"sources":["D:/New folder/VTI_Academy/ReactJS/Final_Demo/Frontend/Group_Management/node_modules/yup/es/util/reach.js"],"sourcesContent":["import { forEach } from 'property-expr';\n\nlet trim = part => part.substr(0, part.length - 1).substr(1);\n\nexport function getIn(schema, path, value, context = value) {\n  let parent, lastPart, lastPartDebug; // root path: ''\n\n  if (!path) return {\n    parent,\n    parentPath: path,\n    schema\n  };\n  forEach(path, (_part, isBracket, isArray) => {\n    let part = isBracket ? trim(_part) : _part;\n    schema = schema.resolve({\n      context,\n      parent,\n      value\n    });\n\n    if (schema.innerType) {\n      let idx = isArray ? parseInt(part, 10) : 0;\n\n      if (value && idx >= value.length) {\n        throw new Error(`Yup.reach cannot resolve an array item at index: ${_part}, in the path: ${path}. ` + `because there is no value at that index. `);\n      }\n\n      parent = value;\n      value = value && value[idx];\n      schema = schema.innerType;\n    } // sometimes the array index part of a path doesn't exist: \"nested.arr.child\"\n    // in these cases the current part is the next schema and should be processed\n    // in this iteration. For cases where the index signature is included this\n    // check will fail and we'll handle the `child` part on the next iteration like normal\n\n\n    if (!isArray) {\n      if (!schema.fields || !schema.fields[part]) throw new Error(`The schema does not contain the path: ${path}. ` + `(failed at: ${lastPartDebug} which is a type: \"${schema._type}\")`);\n      parent = value;\n      value = value && value[part];\n      schema = schema.fields[part];\n    }\n\n    lastPart = part;\n    lastPartDebug = isBracket ? '[' + _part + ']' : '.' + _part;\n  });\n  return {\n    schema,\n    parent,\n    parentPath: lastPart\n  };\n}\n\nconst reach = (obj, path, value, context) => getIn(obj, path, value, context).schema;\n\nexport default reach;"],"mappings":"AAAA,SAASA,OAAO,QAAQ,eAAe;AAEvC,IAAIC,IAAI,GAAG,SAAPA,IAAIA,CAAGC,IAAI;EAAA,OAAIA,IAAI,CAACC,MAAM,CAAC,CAAC,EAAED,IAAI,CAACE,MAAM,GAAG,CAAC,CAAC,CAACD,MAAM,CAAC,CAAC,CAAC;AAAA;AAE5D,OAAO,SAASE,KAAKA,CAACC,MAAM,EAAEC,IAAI,EAAEC,KAAK,EAAmB;EAAA,IAAjBC,OAAO,GAAAC,SAAA,CAAAN,MAAA,QAAAM,SAAA,QAAAC,SAAA,GAAAD,SAAA,MAAGF,KAAK;EACxD,IAAII,MAAM,EAAEC,QAAQ,EAAEC,aAAa,CAAC,CAAC;;EAErC,IAAI,CAACP,IAAI,EAAE,OAAO;IAChBK,MAAM,EAANA,MAAM;IACNG,UAAU,EAAER,IAAI;IAChBD,MAAM,EAANA;EACF,CAAC;EACDN,OAAO,CAACO,IAAI,EAAE,UAACS,KAAK,EAAEC,SAAS,EAAEC,OAAO,EAAK;IAC3C,IAAIhB,IAAI,GAAGe,SAAS,GAAGhB,IAAI,CAACe,KAAK,CAAC,GAAGA,KAAK;IAC1CV,MAAM,GAAGA,MAAM,CAACa,OAAO,CAAC;MACtBV,OAAO,EAAPA,OAAO;MACPG,MAAM,EAANA,MAAM;MACNJ,KAAK,EAALA;IACF,CAAC,CAAC;IAEF,IAAIF,MAAM,CAACc,SAAS,EAAE;MACpB,IAAIC,GAAG,GAAGH,OAAO,GAAGI,QAAQ,CAACpB,IAAI,EAAE,EAAE,CAAC,GAAG,CAAC;MAE1C,IAAIM,KAAK,IAAIa,GAAG,IAAIb,KAAK,CAACJ,MAAM,EAAE;QAChC,MAAM,IAAImB,KAAK,CAAC,oDAAAC,MAAA,CAAoDR,KAAK,qBAAAQ,MAAA,CAAkBjB,IAAI,qDAAkD,CAAC;MACpJ;MAEAK,MAAM,GAAGJ,KAAK;MACdA,KAAK,GAAGA,KAAK,IAAIA,KAAK,CAACa,GAAG,CAAC;MAC3Bf,MAAM,GAAGA,MAAM,CAACc,SAAS;IAC3B,CAAC,CAAC;IACF;IACA;IACA;;IAGA,IAAI,CAACF,OAAO,EAAE;MACZ,IAAI,CAACZ,MAAM,CAACmB,MAAM,IAAI,CAACnB,MAAM,CAACmB,MAAM,CAACvB,IAAI,CAAC,EAAE,MAAM,IAAIqB,KAAK,CAAC,yCAAAC,MAAA,CAAyCjB,IAAI,yBAAAiB,MAAA,CAAsBV,aAAa,0BAAAU,MAAA,CAAsBlB,MAAM,CAACoB,KAAK,QAAI,CAAC;MACnLd,MAAM,GAAGJ,KAAK;MACdA,KAAK,GAAGA,KAAK,IAAIA,KAAK,CAACN,IAAI,CAAC;MAC5BI,MAAM,GAAGA,MAAM,CAACmB,MAAM,CAACvB,IAAI,CAAC;IAC9B;IAEAW,QAAQ,GAAGX,IAAI;IACfY,aAAa,GAAGG,SAAS,GAAG,GAAG,GAAGD,KAAK,GAAG,GAAG,GAAG,GAAG,GAAGA,KAAK;EAC7D,CAAC,CAAC;EACF,OAAO;IACLV,MAAM,EAANA,MAAM;IACNM,MAAM,EAANA,MAAM;IACNG,UAAU,EAAEF;EACd,CAAC;AACH;AAEA,IAAMc,KAAK,GAAG,SAARA,KAAKA,CAAIC,GAAG,EAAErB,IAAI,EAAEC,KAAK,EAAEC,OAAO;EAAA,OAAKJ,KAAK,CAACuB,GAAG,EAAErB,IAAI,EAAEC,KAAK,EAAEC,OAAO,CAAC,CAACH,MAAM;AAAA;AAEpF,eAAeqB,KAAK"},"metadata":{},"sourceType":"module"}