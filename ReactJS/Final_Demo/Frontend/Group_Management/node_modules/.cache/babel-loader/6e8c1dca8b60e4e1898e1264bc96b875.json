{"ast":null,"code":"/*!\nFullCalendar v5.1.0\nDocs & License: https://fullcalendar.io/\n(c) 2020 Adam Shaw\n*/\nimport './main.css';\nimport { hasBgRendering, Splitter, rangeContainsMarker, startOfDay, asRoughMs, createDuration, createRef, RefMap, createElement, PositionCache, BaseComponent, RenderHook, createFormatter, ViewContextType, wholeDivideDurations, formatIsoTimeString, addDurations, diffDays, buildNavLinkData, WeekNumberRoot, getStickyHeaderDates, ViewRoot, SimpleScrollGrid, getStickyFooterScrollbar, NowTimer, NowIndicatorRoot, DateComponent, renderScrollShim, sortEventSegs, compareByFieldSpecs, buildSegCompareObj, StandardEvent, config, DayCellRoot, getSegMeta, buildEventRangeKey, BgEvent, renderFill, Fragment, DayCellContent, memoize, multiplyDuration, intersectRanges, Slicer, DayHeader, DaySeriesModel, DayTableModel, createPlugin } from '@fullcalendar/common';\nimport { __extends, __assign } from 'tslib';\nimport { DayTable } from '@fullcalendar/daygrid';\nvar AllDaySplitter = /** @class */function (_super) {\n  __extends(AllDaySplitter, _super);\n  function AllDaySplitter() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  AllDaySplitter.prototype.getKeyInfo = function () {\n    return {\n      allDay: {},\n      timed: {}\n    };\n  };\n  AllDaySplitter.prototype.getKeysForDateSpan = function (dateSpan) {\n    if (dateSpan.allDay) {\n      return ['allDay'];\n    } else {\n      return ['timed'];\n    }\n  };\n  AllDaySplitter.prototype.getKeysForEventDef = function (eventDef) {\n    if (!eventDef.allDay) {\n      return ['timed'];\n    } else if (hasBgRendering(eventDef)) {\n      return ['timed', 'allDay'];\n    } else {\n      return ['allDay'];\n    }\n  };\n  return AllDaySplitter;\n}(Splitter);\nvar TimeColsSlatsCoords = /** @class */function () {\n  function TimeColsSlatsCoords(positions, dateProfile, slatMetas) {\n    this.positions = positions;\n    this.dateProfile = dateProfile;\n    this.slatMetas = slatMetas;\n  }\n  TimeColsSlatsCoords.prototype.safeComputeTop = function (date) {\n    var dateProfile = this.dateProfile;\n    if (rangeContainsMarker(dateProfile.currentRange, date)) {\n      var startOfDayDate = startOfDay(date);\n      var timeMs = date.valueOf() - startOfDayDate.valueOf();\n      if (timeMs >= asRoughMs(dateProfile.slotMinTime) && timeMs < asRoughMs(dateProfile.slotMaxTime)) {\n        return this.computeTimeTop(createDuration(timeMs));\n      }\n    }\n  };\n  // Computes the top coordinate, relative to the bounds of the grid, of the given date.\n  // A `startOfDayDate` must be given for avoiding ambiguity over how to treat midnight.\n  TimeColsSlatsCoords.prototype.computeDateTop = function (when, startOfDayDate) {\n    if (!startOfDayDate) {\n      startOfDayDate = startOfDay(when);\n    }\n    return this.computeTimeTop(createDuration(when.valueOf() - startOfDayDate.valueOf()));\n  };\n  // Computes the top coordinate, relative to the bounds of the grid, of the given time (a Duration).\n  // This is a makeshify way to compute the time-top. Assumes all slatMetas dates are uniform.\n  // Eventually allow computation with arbirary slat dates.\n  TimeColsSlatsCoords.prototype.computeTimeTop = function (duration) {\n    var _a = this,\n      positions = _a.positions,\n      dateProfile = _a.dateProfile,\n      slatMetas = _a.slatMetas;\n    var len = positions.els.length;\n    var slotDurationMs = slatMetas[1].date.valueOf() - slatMetas[0].date.valueOf(); // we assume dates are uniform\n    var slatCoverage = (duration.milliseconds - asRoughMs(dateProfile.slotMinTime)) / slotDurationMs; // floating-point value of # of slots covered\n    var slatIndex;\n    var slatRemainder;\n    // compute a floating-point number for how many slats should be progressed through.\n    // from 0 to number of slats (inclusive)\n    // constrained because slotMinTime/slotMaxTime might be customized.\n    slatCoverage = Math.max(0, slatCoverage);\n    slatCoverage = Math.min(len, slatCoverage);\n    // an integer index of the furthest whole slat\n    // from 0 to number slats (*exclusive*, so len-1)\n    slatIndex = Math.floor(slatCoverage);\n    slatIndex = Math.min(slatIndex, len - 1);\n    // how much further through the slatIndex slat (from 0.0-1.0) must be covered in addition.\n    // could be 1.0 if slatCoverage is covering *all* the slots\n    slatRemainder = slatCoverage - slatIndex;\n    return positions.tops[slatIndex] + positions.getHeight(slatIndex) * slatRemainder;\n  };\n  return TimeColsSlatsCoords;\n}();\n\n// potential nice values for the slot-duration and interval-duration\n// from largest to smallest\nvar STOCK_SUB_DURATIONS = [{\n  hours: 1\n}, {\n  minutes: 30\n}, {\n  minutes: 15\n}, {\n  seconds: 30\n}, {\n  seconds: 15\n}];\n/*\nfor the horizontal \"slats\" that run width-wise. Has a time axis on a side. Depends on RTL.\n*/\nvar TimeColsSlats = /** @class */function (_super) {\n  __extends(TimeColsSlats, _super);\n  function TimeColsSlats() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.rootElRef = createRef();\n    _this.slatElRefs = new RefMap();\n    return _this;\n  }\n  TimeColsSlats.prototype.render = function () {\n    var _a = this,\n      props = _a.props,\n      context = _a.context;\n    return createElement(\"div\", {\n      className: 'fc-timegrid-slots',\n      ref: this.rootElRef\n    }, createElement(\"table\", {\n      className: context.theme.getClass('table'),\n      style: {\n        minWidth: props.tableMinWidth,\n        width: props.clientWidth,\n        height: props.minHeight\n      }\n    }, props.tableColGroupNode /* relies on there only being a single <col> for the axis */, createElement(TimeColsSlatsBody, {\n      slatElRefs: this.slatElRefs,\n      axis: props.axis,\n      slatMetas: props.slatMetas\n    })));\n  };\n  TimeColsSlats.prototype.componentDidMount = function () {\n    this.updateSizing();\n  };\n  TimeColsSlats.prototype.componentDidUpdate = function () {\n    this.updateSizing();\n  };\n  TimeColsSlats.prototype.componentWillUnmount = function () {\n    if (this.props.onCoords) {\n      this.props.onCoords(null);\n    }\n  };\n  TimeColsSlats.prototype.updateSizing = function () {\n    var props = this.props;\n    if (props.onCoords && props.clientWidth !== null // means sizing has stabilized\n    ) {\n      var rootEl = this.rootElRef.current;\n      if (rootEl.offsetHeight) {\n        // not hidden by css\n        props.onCoords(new TimeColsSlatsCoords(new PositionCache(this.rootElRef.current, collectSlatEls(this.slatElRefs.currentMap, props.slatMetas), false, true // vertical\n        ), this.props.dateProfile, props.slatMetas));\n      }\n    }\n  };\n  return TimeColsSlats;\n}(BaseComponent);\nfunction collectSlatEls(elMap, slatMetas) {\n  return slatMetas.map(function (slatMeta) {\n    return elMap[slatMeta.key];\n  });\n}\nvar TimeColsSlatsBody = /** @class */function (_super) {\n  __extends(TimeColsSlatsBody, _super);\n  function TimeColsSlatsBody() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  TimeColsSlatsBody.prototype.render = function () {\n    var _a = this,\n      props = _a.props,\n      context = _a.context;\n    var options = context.options;\n    var slatElRefs = props.slatElRefs;\n    return createElement(\"tbody\", null, props.slatMetas.map(function (slatMeta, i) {\n      var hookProps = {\n        time: slatMeta.time,\n        date: context.dateEnv.toDate(slatMeta.date),\n        view: context.viewApi\n      };\n      var classNames = ['fc-timegrid-slot', 'fc-timegrid-slot-lane', slatMeta.isLabeled ? '' : 'fc-timegrid-slot-minor'];\n      return createElement(\"tr\", {\n        key: slatMeta.key,\n        ref: slatElRefs.createRef(slatMeta.key)\n      }, props.axis && createElement(TimeColsAxisCell, __assign({}, slatMeta)), createElement(RenderHook, {\n        hookProps: hookProps,\n        classNames: options.slotLaneClassNames,\n        content: options.slotLaneContent,\n        didMount: options.slotLaneDidMount,\n        willUnmount: options.slotLaneWillUnmount\n      }, function (rootElRef, customClassNames, innerElRef, innerContent) {\n        return createElement(\"td\", {\n          ref: rootElRef,\n          className: classNames.concat(customClassNames).join(' '),\n          \"data-time\": slatMeta.isoTimeStr\n        }, innerContent);\n      }));\n    }));\n  };\n  return TimeColsSlatsBody;\n}(BaseComponent);\nvar DEFAULT_SLAT_LABEL_FORMAT = createFormatter({\n  hour: 'numeric',\n  minute: '2-digit',\n  omitZeroMinute: true,\n  meridiem: 'short'\n});\nfunction TimeColsAxisCell(props) {\n  var classNames = ['fc-timegrid-slot', 'fc-timegrid-slot-label', props.isLabeled ? 'fc-scrollgrid-shrink' : 'fc-timegrid-slot-minor'];\n  return createElement(ViewContextType.Consumer, null, function (context) {\n    if (!props.isLabeled) {\n      return createElement(\"td\", {\n        className: classNames.join(' '),\n        \"data-time\": props.isoTimeStr\n      });\n    } else {\n      var dateEnv = context.dateEnv,\n        options = context.options,\n        viewApi = context.viewApi;\n      var labelFormat =\n      // TODO: fully pre-parse\n      options.slotLabelFormat == null ? DEFAULT_SLAT_LABEL_FORMAT : Array.isArray(options.slotLabelFormat) ? createFormatter(options.slotLabelFormat[0]) : createFormatter(options.slotLabelFormat);\n      var hookProps = {\n        time: props.time,\n        date: dateEnv.toDate(props.date),\n        view: viewApi,\n        text: dateEnv.format(props.date, labelFormat)\n      };\n      return createElement(RenderHook, {\n        hookProps: hookProps,\n        classNames: options.slotLabelClassNames,\n        content: options.slotLabelContent,\n        defaultContent: renderInnerContent,\n        didMount: options.slotLabelDidMount,\n        willUnmount: options.slotLabelWillUnmount\n      }, function (rootElRef, customClassNames, innerElRef, innerContent) {\n        return createElement(\"td\", {\n          ref: rootElRef,\n          className: classNames.concat(customClassNames).join(' '),\n          \"data-time\": props.isoTimeStr\n        }, createElement(\"div\", {\n          className: 'fc-timegrid-slot-label-frame fc-scrollgrid-shrink-frame'\n        }, createElement(\"div\", {\n          className: 'fc-timegrid-slot-label-cushion fc-scrollgrid-shrink-cushion',\n          ref: innerElRef\n        }, innerContent)));\n      });\n    }\n  });\n}\nfunction renderInnerContent(props) {\n  return props.text;\n}\nfunction buildSlatMetas(slotMinTime, slotMaxTime, explicitLabelInterval, slotDuration, dateEnv) {\n  var dayStart = new Date(0);\n  var slatTime = slotMinTime;\n  var slatIterator = createDuration(0);\n  var labelInterval = explicitLabelInterval || computeLabelInterval(slotDuration);\n  var metas = [];\n  while (asRoughMs(slatTime) < asRoughMs(slotMaxTime)) {\n    var date = dateEnv.add(dayStart, slatTime);\n    var isLabeled = wholeDivideDurations(slatIterator, labelInterval) !== null;\n    metas.push({\n      date: date,\n      time: slatTime,\n      key: date.toISOString(),\n      isoTimeStr: formatIsoTimeString(date),\n      isLabeled: isLabeled\n    });\n    slatTime = addDurations(slatTime, slotDuration);\n    slatIterator = addDurations(slatIterator, slotDuration);\n  }\n  return metas;\n}\n// Computes an automatic value for slotLabelInterval\nfunction computeLabelInterval(slotDuration) {\n  var i;\n  var labelInterval;\n  var slotsPerLabel;\n  // find the smallest stock label interval that results in more than one slots-per-label\n  for (i = STOCK_SUB_DURATIONS.length - 1; i >= 0; i--) {\n    labelInterval = createDuration(STOCK_SUB_DURATIONS[i]);\n    slotsPerLabel = wholeDivideDurations(labelInterval, slotDuration);\n    if (slotsPerLabel !== null && slotsPerLabel > 1) {\n      return labelInterval;\n    }\n  }\n  return slotDuration; // fall back\n}\n\nvar DEFAULT_WEEK_NUM_FORMAT = createFormatter({\n  week: 'short'\n});\nvar AUTO_ALL_DAY_MAX_EVENT_ROWS = 5;\nvar TimeColsView = /** @class */function (_super) {\n  __extends(TimeColsView, _super);\n  function TimeColsView() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.allDaySplitter = new AllDaySplitter(); // for use by subclasses\n    _this.headerElRef = createRef();\n    _this.rootElRef = createRef();\n    _this.scrollerElRef = createRef();\n    _this.state = {\n      slatCoords: null\n    };\n    _this.handleScrollTopRequest = function (scrollTop) {\n      var scrollerEl = _this.scrollerElRef.current;\n      if (scrollerEl) {\n        // TODO: not sure how this could ever be null. weirdness with the reducer\n        scrollerEl.scrollTop = scrollTop;\n      }\n    };\n    /* Header Render Methods\n    ------------------------------------------------------------------------------------------------------------------*/\n    _this.renderHeadAxis = function (frameHeight) {\n      if (frameHeight === void 0) {\n        frameHeight = '';\n      }\n      var options = _this.context.options;\n      var dateProfile = _this.props.dateProfile;\n      var range = dateProfile.renderRange;\n      var dayCnt = diffDays(range.start, range.end);\n      var navLinkAttrs = options.navLinks && dayCnt === 1 // only do in day views (to avoid doing in week views that dont need it)\n      ? {\n        'data-navlink': buildNavLinkData(range.start, 'week'),\n        tabIndex: 0\n      } : {};\n      if (options.weekNumbers) {\n        return createElement(WeekNumberRoot, {\n          date: range.start,\n          defaultFormat: DEFAULT_WEEK_NUM_FORMAT\n        }, function (rootElRef, classNames, innerElRef, innerContent) {\n          return createElement(\"th\", {\n            ref: rootElRef,\n            className: ['fc-timegrid-axis', 'fc-scrollgrid-shrink'].concat(classNames).join(' ')\n          }, createElement(\"div\", {\n            className: 'fc-timegrid-axis-frame fc-scrollgrid-shrink-frame fc-timegrid-axis-frame-liquid',\n            style: {\n              height: frameHeight\n            }\n          }, createElement(\"a\", __assign({\n            ref: innerElRef,\n            className: 'fc-timegrid-axis-cushion fc-scrollgrid-shrink-cushion'\n          }, navLinkAttrs), innerContent)));\n        });\n      }\n      return createElement(\"th\", {\n        className: 'fc-timegrid-axis'\n      }, createElement(\"div\", {\n        className: 'fc-timegrid-axis-frame',\n        style: {\n          height: frameHeight\n        }\n      }));\n    };\n    /* Table Component Render Methods\n    ------------------------------------------------------------------------------------------------------------------*/\n    // only a one-way height sync. we don't send the axis inner-content height to the DayGrid,\n    // but DayGrid still needs to have classNames on inner elements in order to measure.\n    _this.renderTableRowAxis = function (rowHeight) {\n      var _a = _this.context,\n        options = _a.options,\n        viewApi = _a.viewApi;\n      var hookProps = {\n        text: options.allDayText,\n        view: viewApi\n      };\n      return (\n        // TODO: make reusable hook. used in list view too\n        createElement(RenderHook, {\n          hookProps: hookProps,\n          classNames: options.allDayClassNames,\n          content: options.allDayContent,\n          defaultContent: renderAllDayInner,\n          didMount: options.allDayDidMount,\n          willUnmount: options.allDayWillUnmount\n        }, function (rootElRef, classNames, innerElRef, innerContent) {\n          return createElement(\"td\", {\n            ref: rootElRef,\n            className: ['fc-timegrid-axis', 'fc-scrollgrid-shrink'].concat(classNames).join(' ')\n          }, createElement(\"div\", {\n            className: 'fc-timegrid-axis-frame fc-scrollgrid-shrink-frame' + (rowHeight == null ? ' fc-timegrid-axis-frame-liquid' : ''),\n            style: {\n              height: rowHeight\n            }\n          }, createElement(\"span\", {\n            className: 'fc-timegrid-axis-cushion fc-scrollgrid-shrink-cushion',\n            ref: innerElRef\n          }, innerContent)));\n        })\n      );\n    };\n    _this.handleSlatCoords = function (slatCoords) {\n      _this.setState({\n        slatCoords: slatCoords\n      });\n    };\n    return _this;\n  }\n  // rendering\n  // ----------------------------------------------------------------------------------------------------\n  TimeColsView.prototype.renderSimpleLayout = function (headerRowContent, allDayContent, timeContent) {\n    var _a = this,\n      context = _a.context,\n      props = _a.props;\n    var sections = [];\n    var stickyHeaderDates = getStickyHeaderDates(context.options);\n    if (headerRowContent) {\n      sections.push({\n        type: 'header',\n        key: 'header',\n        isSticky: stickyHeaderDates,\n        chunk: {\n          elRef: this.headerElRef,\n          tableClassName: 'fc-col-header',\n          rowContent: headerRowContent\n        }\n      });\n    }\n    if (allDayContent) {\n      sections.push({\n        type: 'body',\n        key: 'all-day',\n        chunk: {\n          content: allDayContent\n        }\n      });\n      sections.push({\n        type: 'body',\n        key: 'all-day-divider',\n        outerContent:\n        // TODO: rename to cellContent so don't need to define <tr>?\n        createElement(\"tr\", {\n          className: 'fc-scrollgrid-section'\n        }, createElement(\"td\", {\n          className: 'fc-timegrid-divider ' + context.theme.getClass('tableCellShaded')\n        }))\n      });\n    }\n    sections.push({\n      type: 'body',\n      key: 'body',\n      liquid: true,\n      expandRows: Boolean(context.options.expandRows),\n      chunk: {\n        scrollerElRef: this.scrollerElRef,\n        content: timeContent\n      }\n    });\n    return createElement(ViewRoot, {\n      viewSpec: context.viewSpec,\n      elRef: this.rootElRef\n    }, function (rootElRef, classNames) {\n      return createElement(\"div\", {\n        className: ['fc-timegrid'].concat(classNames).join(' '),\n        ref: rootElRef\n      }, createElement(SimpleScrollGrid, {\n        liquid: !props.isHeightAuto && !props.forPrint,\n        cols: [{\n          width: 'shrink'\n        }],\n        sections: sections\n      }));\n    });\n  };\n  TimeColsView.prototype.renderHScrollLayout = function (headerRowContent, allDayContent, timeContent, colCnt, dayMinWidth, slatMetas, slatCoords // yuck\n  ) {\n    var _this = this;\n    var ScrollGrid = this.context.pluginHooks.scrollGridImpl;\n    if (!ScrollGrid) {\n      throw new Error('No ScrollGrid implementation');\n    }\n    var _a = this,\n      context = _a.context,\n      props = _a.props;\n    var stickyHeaderDates = !props.forPrint && getStickyHeaderDates(context.options);\n    var stickyFooterScrollbar = !props.forPrint && getStickyFooterScrollbar(context.options);\n    var sections = [];\n    if (headerRowContent) {\n      sections.push({\n        type: 'header',\n        key: 'header',\n        isSticky: stickyHeaderDates,\n        syncRowHeights: true,\n        chunks: [{\n          key: 'axis',\n          rowContent: function rowContent(arg) {\n            return createElement(\"tr\", null, _this.renderHeadAxis(arg.rowSyncHeights[0]));\n          }\n        }, {\n          key: 'cols',\n          elRef: this.headerElRef,\n          tableClassName: 'fc-col-header',\n          rowContent: headerRowContent\n        }]\n      });\n    }\n    if (allDayContent) {\n      sections.push({\n        type: 'body',\n        key: 'all-day',\n        syncRowHeights: true,\n        chunks: [{\n          key: 'axis',\n          rowContent: function rowContent(contentArg) {\n            return createElement(\"tr\", null, _this.renderTableRowAxis(contentArg.rowSyncHeights[0]));\n          }\n        }, {\n          key: 'cols',\n          content: allDayContent\n        }]\n      });\n      sections.push({\n        key: 'all-day-divider',\n        type: 'body',\n        outerContent:\n        // TODO: rename to cellContent so don't need to define <tr>?\n        createElement(\"tr\", {\n          className: 'fc-scrollgrid-section'\n        }, createElement(\"td\", {\n          colSpan: 2,\n          className: 'fc-timegrid-divider ' + context.theme.getClass('tableCellShaded')\n        }))\n      });\n    }\n    var isNowIndicator = context.options.nowIndicator;\n    sections.push({\n      type: 'body',\n      key: 'body',\n      liquid: true,\n      expandRows: Boolean(context.options.expandRows),\n      chunks: [{\n        key: 'axis',\n        content: function content(arg) {\n          // TODO: make this now-indicator arrow more DRY with TimeColsContent\n          return createElement(\"div\", {\n            className: 'fc-timegrid-axis-chunk'\n          }, createElement(\"table\", null, arg.tableColGroupNode, createElement(\"tbody\", null, createElement(TimeBodyAxis, {\n            slatMetas: slatMetas\n          }))), createElement(\"div\", {\n            className: 'fc-timegrid-now-indicator-container'\n          }, createElement(NowTimer, {\n            unit: isNowIndicator ? 'minute' : 'day' /* hacky */\n          }, function (nowDate) {\n            var nowIndicatorTop = isNowIndicator && slatCoords && slatCoords.safeComputeTop(nowDate); // might return void\n            if (typeof nowIndicatorTop === 'number') {\n              return createElement(NowIndicatorRoot, {\n                isAxis: true,\n                date: nowDate\n              }, function (rootElRef, classNames, innerElRef, innerContent) {\n                return createElement(\"div\", {\n                  ref: rootElRef,\n                  className: ['fc-timegrid-now-indicator-arrow'].concat(classNames).join(' '),\n                  style: {\n                    top: nowIndicatorTop\n                  }\n                }, innerContent);\n              });\n            }\n          })));\n        }\n      }, {\n        key: 'cols',\n        scrollerElRef: this.scrollerElRef,\n        content: timeContent\n      }]\n    });\n    if (stickyFooterScrollbar) {\n      sections.push({\n        key: 'footer',\n        type: 'footer',\n        isSticky: true,\n        chunks: [{\n          key: 'axis',\n          content: renderScrollShim\n        }, {\n          key: 'cols',\n          content: renderScrollShim\n        }]\n      });\n    }\n    return createElement(ViewRoot, {\n      viewSpec: context.viewSpec,\n      elRef: this.rootElRef\n    }, function (rootElRef, classNames) {\n      return createElement(\"div\", {\n        className: ['fc-timegrid'].concat(classNames).join(' '),\n        ref: rootElRef\n      }, createElement(ScrollGrid, {\n        liquid: !props.isHeightAuto && !props.forPrint,\n        colGroups: [{\n          width: 'shrink',\n          cols: [{\n            width: 'shrink'\n          }]\n        }, {\n          cols: [{\n            span: colCnt,\n            minWidth: dayMinWidth\n          }]\n        }],\n        sections: sections\n      }));\n    });\n  };\n  /* Dimensions\n  ------------------------------------------------------------------------------------------------------------------*/\n  TimeColsView.prototype.getAllDayMaxEventProps = function () {\n    var _a = this.context.options,\n      dayMaxEvents = _a.dayMaxEvents,\n      dayMaxEventRows = _a.dayMaxEventRows;\n    if (dayMaxEvents === true || dayMaxEventRows === true) {\n      // is auto?\n      dayMaxEvents = undefined;\n      dayMaxEventRows = AUTO_ALL_DAY_MAX_EVENT_ROWS; // make sure \"auto\" goes to a real number\n    }\n\n    return {\n      dayMaxEvents: dayMaxEvents,\n      dayMaxEventRows: dayMaxEventRows\n    };\n  };\n  return TimeColsView;\n}(DateComponent);\nfunction renderAllDayInner(hookProps) {\n  return hookProps.text;\n}\nvar TimeBodyAxis = /** @class */function (_super) {\n  __extends(TimeBodyAxis, _super);\n  function TimeBodyAxis() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  TimeBodyAxis.prototype.render = function () {\n    return this.props.slatMetas.map(function (slatMeta) {\n      return createElement(\"tr\", {\n        key: slatMeta.key\n      }, createElement(TimeColsAxisCell, __assign({}, slatMeta)));\n    });\n  };\n  return TimeBodyAxis;\n}(BaseComponent);\nfunction splitSegsByCol(segs, colCnt) {\n  var segsByCol = [];\n  var i;\n  for (i = 0; i < colCnt; i++) {\n    segsByCol.push([]);\n  }\n  if (segs) {\n    for (i = 0; i < segs.length; i++) {\n      segsByCol[segs[i].col].push(segs[i]);\n    }\n  }\n  return segsByCol;\n}\nfunction splitInteractionByCol(ui, colCnt) {\n  var byRow = [];\n  if (!ui) {\n    for (var i = 0; i < colCnt; i++) {\n      byRow[i] = null;\n    }\n  } else {\n    for (var i = 0; i < colCnt; i++) {\n      byRow[i] = {\n        affectedInstances: ui.affectedInstances,\n        isEvent: ui.isEvent,\n        segs: []\n      };\n    }\n    for (var _i = 0, _a = ui.segs; _i < _a.length; _i++) {\n      var seg = _a[_i];\n      byRow[seg.col].segs.push(seg);\n    }\n  }\n  return byRow;\n}\n\n// UNFORTUNATELY, assigns results to the top/bottom/level/forwardCoord/backwardCoord props of the actual segs.\n// TODO: return hash (by instanceId) of results\nfunction computeSegCoords(segs, dayDate, slatCoords, eventMinHeight, eventOrderSpecs) {\n  computeSegVerticals(segs, dayDate, slatCoords, eventMinHeight);\n  return computeSegHorizontals(segs, eventOrderSpecs); // requires top/bottom from computeSegVerticals\n}\n// For each segment in an array, computes and assigns its top and bottom properties\nfunction computeSegVerticals(segs, dayDate, slatCoords, eventMinHeight) {\n  for (var _i = 0, segs_1 = segs; _i < segs_1.length; _i++) {\n    var seg = segs_1[_i];\n    seg.top = slatCoords.computeDateTop(seg.start, dayDate);\n    seg.bottom = Math.max(seg.top + (eventMinHeight || 0),\n    // yuck\n    slatCoords.computeDateTop(seg.end, dayDate));\n  }\n}\n// Given an array of segments that are all in the same column, sets the backwardCoord and forwardCoord on each.\n// Assumed the segs are already ordered.\n// NOTE: Also reorders the given array by date!\nfunction computeSegHorizontals(segs, eventOrderSpecs) {\n  // IMPORTANT TO CLEAR OLD RESULTS :(\n  for (var _i = 0, segs_2 = segs; _i < segs_2.length; _i++) {\n    var seg = segs_2[_i];\n    seg.level = null;\n    seg.forwardCoord = null;\n    seg.backwardCoord = null;\n    seg.forwardPressure = null;\n  }\n  segs = sortEventSegs(segs, eventOrderSpecs);\n  var level0;\n  var levels = buildSlotSegLevels(segs);\n  computeForwardSlotSegs(levels);\n  if (level0 = levels[0]) {\n    for (var _a = 0, level0_1 = level0; _a < level0_1.length; _a++) {\n      var seg = level0_1[_a];\n      computeSlotSegPressures(seg);\n    }\n    for (var _b = 0, level0_2 = level0; _b < level0_2.length; _b++) {\n      var seg = level0_2[_b];\n      computeSegForwardBack(seg, 0, 0, eventOrderSpecs);\n    }\n  }\n  return segs;\n}\n// Builds an array of segments \"levels\". The first level will be the leftmost tier of segments if the calendar is\n// left-to-right, or the rightmost if the calendar is right-to-left. Assumes the segments are already ordered by date.\nfunction buildSlotSegLevels(segs) {\n  var levels = [];\n  var i;\n  var seg;\n  var j;\n  for (i = 0; i < segs.length; i++) {\n    seg = segs[i];\n    // go through all the levels and stop on the first level where there are no collisions\n    for (j = 0; j < levels.length; j++) {\n      if (!computeSlotSegCollisions(seg, levels[j]).length) {\n        break;\n      }\n    }\n    seg.level = j;\n    (levels[j] || (levels[j] = [])).push(seg);\n  }\n  return levels;\n}\n// Find all the segments in `otherSegs` that vertically collide with `seg`.\n// Append into an optionally-supplied `results` array and return.\nfunction computeSlotSegCollisions(seg, otherSegs, results) {\n  if (results === void 0) {\n    results = [];\n  }\n  for (var i = 0; i < otherSegs.length; i++) {\n    if (isSlotSegCollision(seg, otherSegs[i])) {\n      results.push(otherSegs[i]);\n    }\n  }\n  return results;\n}\n// Do these segments occupy the same vertical space?\nfunction isSlotSegCollision(seg1, seg2) {\n  return seg1.bottom > seg2.top && seg1.top < seg2.bottom;\n}\n// For every segment, figure out the other segments that are in subsequent\n// levels that also occupy the same vertical space. Accumulate in seg.forwardSegs\nfunction computeForwardSlotSegs(levels) {\n  var i;\n  var level;\n  var j;\n  var seg;\n  var k;\n  for (i = 0; i < levels.length; i++) {\n    level = levels[i];\n    for (j = 0; j < level.length; j++) {\n      seg = level[j];\n      seg.forwardSegs = [];\n      for (k = i + 1; k < levels.length; k++) {\n        computeSlotSegCollisions(seg, levels[k], seg.forwardSegs);\n      }\n    }\n  }\n}\n// Figure out which path forward (via seg.forwardSegs) results in the longest path until\n// the furthest edge is reached. The number of segments in this path will be seg.forwardPressure\nfunction computeSlotSegPressures(seg) {\n  var forwardSegs = seg.forwardSegs;\n  var forwardPressure = 0;\n  var i;\n  var forwardSeg;\n  if (seg.forwardPressure == null) {\n    // not already computed\n    for (i = 0; i < forwardSegs.length; i++) {\n      forwardSeg = forwardSegs[i];\n      // figure out the child's maximum forward path\n      computeSlotSegPressures(forwardSeg);\n      // either use the existing maximum, or use the child's forward pressure\n      // plus one (for the forwardSeg itself)\n      forwardPressure = Math.max(forwardPressure, 1 + forwardSeg.forwardPressure);\n    }\n    seg.forwardPressure = forwardPressure;\n  }\n}\n// Calculate seg.forwardCoord and seg.backwardCoord for the segment, where both values range\n// from 0 to 1. If the calendar is left-to-right, the seg.backwardCoord maps to \"left\" and\n// seg.forwardCoord maps to \"right\" (via percentage). Vice-versa if the calendar is right-to-left.\n//\n// The segment might be part of a \"series\", which means consecutive segments with the same pressure\n// who's width is unknown until an edge has been hit. `seriesBackwardPressure` is the number of\n// segments behind this one in the current series, and `seriesBackwardCoord` is the starting\n// coordinate of the first segment in the series.\nfunction computeSegForwardBack(seg, seriesBackwardPressure, seriesBackwardCoord, eventOrderSpecs) {\n  var forwardSegs = seg.forwardSegs;\n  var i;\n  if (seg.forwardCoord == null) {\n    // not already computed\n    if (!forwardSegs.length) {\n      // if there are no forward segments, this segment should butt up against the edge\n      seg.forwardCoord = 1;\n    } else {\n      // sort highest pressure first\n      sortForwardSegs(forwardSegs, eventOrderSpecs);\n      // this segment's forwardCoord will be calculated from the backwardCoord of the\n      // highest-pressure forward segment.\n      computeSegForwardBack(forwardSegs[0], seriesBackwardPressure + 1, seriesBackwardCoord, eventOrderSpecs);\n      seg.forwardCoord = forwardSegs[0].backwardCoord;\n    }\n    // calculate the backwardCoord from the forwardCoord. consider the series\n    seg.backwardCoord = seg.forwardCoord - (seg.forwardCoord - seriesBackwardCoord) / (\n    // available width for series\n    seriesBackwardPressure + 1); // # of segments in the series\n    // use this segment's coordinates to computed the coordinates of the less-pressurized\n    // forward segments\n    for (i = 0; i < forwardSegs.length; i++) {\n      computeSegForwardBack(forwardSegs[i], 0, seg.forwardCoord, eventOrderSpecs);\n    }\n  }\n}\nfunction sortForwardSegs(forwardSegs, eventOrderSpecs) {\n  var objs = forwardSegs.map(buildTimeGridSegCompareObj);\n  var specs = [\n  // put higher-pressure first\n  {\n    field: 'forwardPressure',\n    order: -1\n  },\n  // put segments that are closer to initial edge first (and favor ones with no coords yet)\n  {\n    field: 'backwardCoord',\n    order: 1\n  }].concat(eventOrderSpecs);\n  objs.sort(function (obj0, obj1) {\n    return compareByFieldSpecs(obj0, obj1, specs);\n  });\n  return objs.map(function (c) {\n    return c._seg;\n  });\n}\nfunction buildTimeGridSegCompareObj(seg) {\n  var obj = buildSegCompareObj(seg);\n  obj.forwardPressure = seg.forwardPressure;\n  obj.backwardCoord = seg.backwardCoord;\n  return obj;\n}\nvar DEFAULT_TIME_FORMAT = createFormatter({\n  hour: 'numeric',\n  minute: '2-digit',\n  meridiem: false\n});\nvar TimeColEvent = /** @class */function (_super) {\n  __extends(TimeColEvent, _super);\n  function TimeColEvent() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  TimeColEvent.prototype.render = function () {\n    var classNames = ['fc-timegrid-event', 'fc-v-event'];\n    if (this.props.isCondensed) {\n      classNames.push('fc-timegrid-event-condensed');\n    }\n    return createElement(StandardEvent, __assign({}, this.props, {\n      defaultTimeFormat: DEFAULT_TIME_FORMAT,\n      extraClassNames: classNames\n    }));\n  };\n  return TimeColEvent;\n}(BaseComponent);\nconfig.timeGridEventCondensedHeight = 30;\nvar TimeCol = /** @class */function (_super) {\n  __extends(TimeCol, _super);\n  function TimeCol() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  TimeCol.prototype.render = function () {\n    var _this = this;\n    var _a = this,\n      props = _a.props,\n      context = _a.context;\n    var isSelectMirror = context.options.selectMirror;\n    var mirrorSegs = props.eventDrag && props.eventDrag.segs || props.eventResize && props.eventResize.segs || isSelectMirror && props.dateSelectionSegs || [];\n    var interactionAffectedInstances =\n    // TODO: messy way to compute this\n    props.eventDrag && props.eventDrag.affectedInstances || props.eventResize && props.eventResize.affectedInstances || {};\n    return createElement(DayCellRoot, {\n      elRef: props.elRef,\n      date: props.date,\n      dateProfile: props.dateProfile,\n      todayRange: props.todayRange,\n      extraHookProps: props.extraHookProps\n    }, function (rootElRef, classNames, dataAttrs) {\n      return createElement(\"td\", __assign({\n        ref: rootElRef,\n        className: ['fc-timegrid-col'].concat(classNames, props.extraClassNames || []).join(' ')\n      }, dataAttrs, props.extraDataAttrs), createElement(\"div\", {\n        className: 'fc-timegrid-col-frame'\n      }, createElement(\"div\", {\n        className: 'fc-timegrid-col-bg'\n      }, _this.renderFillSegs(props.businessHourSegs, 'non-business'), _this.renderFillSegs(props.bgEventSegs, 'bg-event'), _this.renderFillSegs(props.dateSelectionSegs, 'highlight')), createElement(\"div\", {\n        className: 'fc-timegrid-col-events'\n      }, _this.renderFgSegs(props.fgEventSegs, interactionAffectedInstances)), createElement(\"div\", {\n        className: 'fc-timegrid-col-events'\n      }, _this.renderFgSegs(mirrorSegs, {}, Boolean(props.eventDrag), Boolean(props.eventResize), Boolean(isSelectMirror)\n      // TODO: pass in left/right instead of using only computeSegTopBottomCss\n      )), createElement(\"div\", {\n        className: 'fc-timegrid-now-indicator-container'\n      }, _this.renderNowIndicator(props.nowIndicatorSegs)), createElement(TimeColMisc, {\n        date: props.date,\n        dateProfile: props.dateProfile,\n        todayRange: props.todayRange,\n        extraHookProps: props.extraHookProps\n      })));\n    });\n  };\n  TimeCol.prototype.renderFgSegs = function (segs, segIsInvisible, isDragging, isResizing, isDateSelecting) {\n    var props = this.props;\n    if (props.forPrint) {\n      return this.renderPrintFgSegs(segs);\n    } else if (props.slatCoords) {\n      return this.renderPositionedFgSegs(segs, segIsInvisible, isDragging, isResizing, isDateSelecting);\n    }\n  };\n  TimeCol.prototype.renderPrintFgSegs = function (segs) {\n    var props = this.props;\n    return segs.map(function (seg) {\n      return createElement(\"div\", {\n        className: 'fc-timegrid-event-harness',\n        key: seg.eventRange.instance.instanceId\n      }, createElement(TimeColEvent, __assign({\n        seg: seg,\n        isDragging: false,\n        isResizing: false,\n        isDateSelecting: false,\n        isSelected: false,\n        isCondensed: false\n      }, getSegMeta(seg, props.todayRange, props.nowDate))));\n    });\n  };\n  TimeCol.prototype.renderPositionedFgSegs = function (segs, segIsInvisible, isDragging, isResizing, isDateSelecting) {\n    var _this = this;\n    var _a = this,\n      context = _a.context,\n      props = _a.props;\n    // assigns TO THE SEGS THEMSELVES\n    // also, receives resorted array\n    segs = computeSegCoords(segs, props.date, props.slatCoords, context.options.eventMinHeight, context.options.eventOrder);\n    return segs.map(function (seg) {\n      var instanceId = seg.eventRange.instance.instanceId;\n      var isMirror = isDragging || isResizing || isDateSelecting;\n      var positionCss = isMirror ? __assign({\n        left: 0,\n        right: 0\n      }, _this.computeSegTopBottomCss(seg)) : _this.computeFgSegPositionCss(seg);\n      return createElement(\"div\", {\n        className: 'fc-timegrid-event-harness' + (seg.level > 0 ? ' fc-timegrid-event-harness-inset' : ''),\n        key: instanceId,\n        style: __assign({\n          visibility: segIsInvisible[instanceId] ? 'hidden' : ''\n        }, positionCss)\n      }, createElement(TimeColEvent, __assign({\n        seg: seg,\n        isDragging: isDragging,\n        isResizing: isResizing,\n        isDateSelecting: isDateSelecting,\n        isSelected: instanceId === props.eventSelection,\n        isCondensed: seg.bottom - seg.top < config.timeGridEventCondensedHeight\n      }, getSegMeta(seg, props.todayRange, props.nowDate))));\n    });\n  };\n  TimeCol.prototype.renderFillSegs = function (segs, fillType) {\n    var _this = this;\n    var _a = this,\n      context = _a.context,\n      props = _a.props;\n    if (!props.slatCoords) {\n      return;\n    }\n    // BAD: assigns TO THE SEGS THEMSELVES\n    computeSegVerticals(segs, props.date, props.slatCoords, context.options.eventMinHeight);\n    var children = segs.map(function (seg) {\n      return createElement(\"div\", {\n        key: buildEventRangeKey(seg.eventRange),\n        className: 'fc-timegrid-bg-harness',\n        style: _this.computeSegTopBottomCss(seg)\n      }, fillType === 'bg-event' ? createElement(BgEvent, __assign({\n        seg: seg\n      }, getSegMeta(seg, props.todayRange, props.nowDate))) : renderFill(fillType));\n    });\n    return createElement(Fragment, null, children);\n  };\n  TimeCol.prototype.renderNowIndicator = function (segs) {\n    var _a = this.props,\n      slatCoords = _a.slatCoords,\n      date = _a.date;\n    if (!slatCoords) {\n      return;\n    }\n    return segs.map(function (seg, i) {\n      return createElement(NowIndicatorRoot, {\n        isAxis: false,\n        date: date,\n        key: i /* key doesn't matter. will only ever be one */\n      }, function (rootElRef, classNames, innerElRef, innerContent) {\n        return createElement(\"div\", {\n          ref: rootElRef,\n          className: ['fc-timegrid-now-indicator-line'].concat(classNames).join(' '),\n          style: {\n            top: slatCoords.computeDateTop(seg.start, date)\n          }\n        }, innerContent);\n      });\n    });\n  };\n  TimeCol.prototype.computeFgSegPositionCss = function (seg) {\n    var _a = this.context,\n      isRtl = _a.isRtl,\n      options = _a.options;\n    var shouldOverlap = options.slotEventOverlap;\n    var backwardCoord = seg.backwardCoord; // the left side if LTR. the right side if RTL. floating-point\n    var forwardCoord = seg.forwardCoord; // the right side if LTR. the left side if RTL. floating-point\n    var left; // amount of space from left edge, a fraction of the total width\n    var right; // amount of space from right edge, a fraction of the total width\n    if (shouldOverlap) {\n      // double the width, but don't go beyond the maximum forward coordinate (1.0)\n      forwardCoord = Math.min(1, backwardCoord + (forwardCoord - backwardCoord) * 2);\n    }\n    if (isRtl) {\n      left = 1 - forwardCoord;\n      right = backwardCoord;\n    } else {\n      left = backwardCoord;\n      right = 1 - forwardCoord;\n    }\n    var props = {\n      zIndex: seg.level + 1,\n      left: left * 100 + '%',\n      right: right * 100 + '%'\n    };\n    if (shouldOverlap && seg.forwardPressure) {\n      // add padding to the edge so that forward stacked events don't cover the resizer's icon\n      props[isRtl ? 'marginLeft' : 'marginRight'] = 10 * 2; // 10 is a guesstimate of the icon's width\n    }\n\n    return __assign(__assign({}, props), this.computeSegTopBottomCss(seg));\n  };\n  TimeCol.prototype.computeSegTopBottomCss = function (seg) {\n    return {\n      top: seg.top,\n      bottom: -seg.bottom\n    };\n  };\n  return TimeCol;\n}(BaseComponent);\nvar TimeColMisc = /** @class */function (_super) {\n  __extends(TimeColMisc, _super);\n  function TimeColMisc() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  TimeColMisc.prototype.render = function () {\n    var props = this.props;\n    return createElement(DayCellContent, {\n      date: props.date,\n      dateProfile: props.dateProfile,\n      todayRange: props.todayRange,\n      extraHookProps: props.extraHookProps\n    }, function (innerElRef, innerContent) {\n      return innerContent && createElement(\"div\", {\n        className: 'fc-timegrid-col-misc',\n        ref: innerElRef\n      }, innerContent);\n    });\n  };\n  return TimeColMisc;\n}(BaseComponent);\nvar TimeColsContent = /** @class */function (_super) {\n  __extends(TimeColsContent, _super);\n  function TimeColsContent() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.splitFgEventSegs = memoize(splitSegsByCol);\n    _this.splitBgEventSegs = memoize(splitSegsByCol);\n    _this.splitBusinessHourSegs = memoize(splitSegsByCol);\n    _this.splitNowIndicatorSegs = memoize(splitSegsByCol);\n    _this.splitDateSelectionSegs = memoize(splitSegsByCol);\n    _this.splitEventDrag = memoize(splitInteractionByCol);\n    _this.splitEventResize = memoize(splitInteractionByCol);\n    _this.rootElRef = createRef();\n    _this.cellElRefs = new RefMap();\n    return _this;\n  }\n  TimeColsContent.prototype.render = function () {\n    var _this = this;\n    var _a = this,\n      props = _a.props,\n      context = _a.context;\n    var nowIndicatorTop = context.options.nowIndicator && props.slatCoords && props.slatCoords.safeComputeTop(props.nowDate); // might return void\n    var colCnt = props.cells.length;\n    var fgEventSegsByRow = this.splitFgEventSegs(props.fgEventSegs, colCnt);\n    var bgEventSegsByRow = this.splitBgEventSegs(props.bgEventSegs, colCnt);\n    var businessHourSegsByRow = this.splitBusinessHourSegs(props.businessHourSegs, colCnt);\n    var nowIndicatorSegsByRow = this.splitNowIndicatorSegs(props.nowIndicatorSegs, colCnt);\n    var dateSelectionSegsByRow = this.splitDateSelectionSegs(props.dateSelectionSegs, colCnt);\n    var eventDragByRow = this.splitEventDrag(props.eventDrag, colCnt);\n    var eventResizeByRow = this.splitEventResize(props.eventResize, colCnt);\n    return createElement(\"div\", {\n      className: 'fc-timegrid-cols',\n      ref: this.rootElRef\n    }, createElement(\"table\", {\n      style: {\n        minWidth: props.tableMinWidth,\n        width: props.clientWidth\n      }\n    }, props.tableColGroupNode, createElement(\"tbody\", null, createElement(\"tr\", null, props.axis && createElement(\"td\", {\n      className: 'fc-timegrid-col fc-timegrid-axis'\n    }, createElement(\"div\", {\n      className: 'fc-timegrid-col-frame'\n    }, createElement(\"div\", {\n      className: 'fc-timegrid-now-indicator-container'\n    }, typeof nowIndicatorTop === 'number' && createElement(NowIndicatorRoot, {\n      isAxis: true,\n      date: props.nowDate\n    }, function (rootElRef, classNames, innerElRef, innerContent) {\n      return createElement(\"div\", {\n        ref: rootElRef,\n        className: ['fc-timegrid-now-indicator-arrow'].concat(classNames).join(' '),\n        style: {\n          top: nowIndicatorTop\n        }\n      }, innerContent);\n    })))), props.cells.map(function (cell, i) {\n      return createElement(TimeCol, {\n        key: cell.key,\n        elRef: _this.cellElRefs.createRef(cell.key),\n        dateProfile: props.dateProfile,\n        date: cell.date,\n        nowDate: props.nowDate,\n        todayRange: props.todayRange,\n        extraHookProps: cell.extraHookProps,\n        extraDataAttrs: cell.extraDataAttrs,\n        extraClassNames: cell.extraClassNames,\n        fgEventSegs: fgEventSegsByRow[i],\n        bgEventSegs: bgEventSegsByRow[i],\n        businessHourSegs: businessHourSegsByRow[i],\n        nowIndicatorSegs: nowIndicatorSegsByRow[i],\n        dateSelectionSegs: dateSelectionSegsByRow[i],\n        eventDrag: eventDragByRow[i],\n        eventResize: eventResizeByRow[i],\n        slatCoords: props.slatCoords,\n        eventSelection: props.eventSelection,\n        forPrint: props.forPrint\n      });\n    })))));\n  };\n  TimeColsContent.prototype.componentDidMount = function () {\n    this.updateCoords();\n  };\n  TimeColsContent.prototype.componentDidUpdate = function () {\n    this.updateCoords();\n  };\n  TimeColsContent.prototype.updateCoords = function () {\n    var props = this.props;\n    if (props.onColCoords && props.clientWidth !== null // means sizing has stabilized\n    ) {\n      props.onColCoords(new PositionCache(this.rootElRef.current, collectCellEls(this.cellElRefs.currentMap, props.cells), true,\n      // horizontal\n      false));\n    }\n  };\n  return TimeColsContent;\n}(BaseComponent);\nfunction collectCellEls(elMap, cells) {\n  return cells.map(function (cell) {\n    return elMap[cell.key];\n  });\n}\n\n/* A component that renders one or more columns of vertical time slots\n----------------------------------------------------------------------------------------------------------------------*/\nvar TimeCols = /** @class */function (_super) {\n  __extends(TimeCols, _super);\n  function TimeCols() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.processSlotOptions = memoize(processSlotOptions);\n    _this.state = {\n      slatCoords: null\n    };\n    _this.handleScrollRequest = function (request) {\n      var onScrollTopRequest = _this.props.onScrollTopRequest;\n      var slatCoords = _this.state.slatCoords;\n      if (onScrollTopRequest && slatCoords) {\n        if (request.time) {\n          var top_1 = slatCoords.computeTimeTop(request.time);\n          top_1 = Math.ceil(top_1); // zoom can give weird floating-point values. rather scroll a little bit further\n          if (top_1) {\n            top_1++;\n          } // to overcome top border that slots beyond the first have. looks better\n          onScrollTopRequest(top_1);\n        }\n        return true;\n      }\n    };\n    _this.handleColCoords = function (colCoords) {\n      _this.colCoords = colCoords;\n    };\n    _this.handleSlatCoords = function (slatCoords) {\n      _this.setState({\n        slatCoords: slatCoords\n      });\n      if (_this.props.onSlatCoords) {\n        _this.props.onSlatCoords(slatCoords);\n      }\n    };\n    return _this;\n  }\n  TimeCols.prototype.render = function () {\n    var _a = this,\n      props = _a.props,\n      state = _a.state;\n    return createElement(\"div\", {\n      className: 'fc-timegrid-body',\n      ref: props.rootElRef,\n      style: {\n        // these props are important to give this wrapper correct dimensions for interactions\n        // TODO: if we set it here, can we avoid giving to inner tables?\n        width: props.clientWidth,\n        minWidth: props.tableMinWidth\n      }\n    }, createElement(TimeColsSlats, {\n      axis: props.axis,\n      dateProfile: props.dateProfile,\n      slatMetas: props.slatMetas,\n      clientWidth: props.clientWidth,\n      minHeight: props.expandRows ? props.clientHeight : '',\n      tableMinWidth: props.tableMinWidth,\n      tableColGroupNode: props.axis ? props.tableColGroupNode : null /* axis depends on the colgroup's shrinking */,\n      onCoords: this.handleSlatCoords\n    }), createElement(TimeColsContent, {\n      cells: props.cells,\n      axis: props.axis,\n      dateProfile: props.dateProfile,\n      businessHourSegs: props.businessHourSegs,\n      bgEventSegs: props.bgEventSegs,\n      fgEventSegs: props.fgEventSegs,\n      dateSelectionSegs: props.dateSelectionSegs,\n      eventSelection: props.eventSelection,\n      eventDrag: props.eventDrag,\n      eventResize: props.eventResize,\n      todayRange: props.todayRange,\n      nowDate: props.nowDate,\n      nowIndicatorSegs: props.nowIndicatorSegs,\n      clientWidth: props.clientWidth,\n      tableMinWidth: props.tableMinWidth,\n      tableColGroupNode: props.tableColGroupNode,\n      slatCoords: state.slatCoords,\n      onColCoords: this.handleColCoords,\n      forPrint: props.forPrint\n    }));\n  };\n  TimeCols.prototype.componentDidMount = function () {\n    this.scrollResponder = this.context.createScrollResponder(this.handleScrollRequest);\n  };\n  TimeCols.prototype.componentDidUpdate = function (prevProps) {\n    this.scrollResponder.update(prevProps.dateProfile !== this.props.dateProfile);\n  };\n  TimeCols.prototype.componentWillUnmount = function () {\n    this.scrollResponder.detach();\n  };\n  TimeCols.prototype.positionToHit = function (positionLeft, positionTop) {\n    var _a = this.context,\n      dateEnv = _a.dateEnv,\n      options = _a.options;\n    var colCoords = this.colCoords;\n    var dateProfile = this.props.dateProfile;\n    var slatCoords = this.state.slatCoords;\n    var _b = this.processSlotOptions(this.props.slotDuration, options.snapDuration),\n      snapDuration = _b.snapDuration,\n      snapsPerSlot = _b.snapsPerSlot;\n    var colIndex = colCoords.leftToIndex(positionLeft);\n    var slatIndex = slatCoords.positions.topToIndex(positionTop);\n    if (colIndex != null && slatIndex != null) {\n      var slatTop = slatCoords.positions.tops[slatIndex];\n      var slatHeight = slatCoords.positions.getHeight(slatIndex);\n      var partial = (positionTop - slatTop) / slatHeight; // floating point number between 0 and 1\n      var localSnapIndex = Math.floor(partial * snapsPerSlot); // the snap # relative to start of slat\n      var snapIndex = slatIndex * snapsPerSlot + localSnapIndex;\n      var dayDate = this.props.cells[colIndex].date;\n      var time = addDurations(dateProfile.slotMinTime, multiplyDuration(snapDuration, snapIndex));\n      var start = dateEnv.add(dayDate, time);\n      var end = dateEnv.add(start, snapDuration);\n      return {\n        col: colIndex,\n        dateSpan: {\n          range: {\n            start: start,\n            end: end\n          },\n          allDay: false\n        },\n        dayEl: colCoords.els[colIndex],\n        relativeRect: {\n          left: colCoords.lefts[colIndex],\n          right: colCoords.rights[colIndex],\n          top: slatTop,\n          bottom: slatTop + slatHeight\n        }\n      };\n    }\n  };\n  return TimeCols;\n}(BaseComponent);\nfunction processSlotOptions(slotDuration, snapDurationOverride) {\n  var snapDuration = snapDurationOverride || slotDuration;\n  var snapsPerSlot = wholeDivideDurations(slotDuration, snapDuration);\n  if (snapsPerSlot === null) {\n    snapDuration = slotDuration;\n    snapsPerSlot = 1;\n    // TODO: say warning?\n  }\n\n  return {\n    snapDuration: snapDuration,\n    snapsPerSlot: snapsPerSlot\n  };\n}\nvar DayTimeCols = /** @class */function (_super) {\n  __extends(DayTimeCols, _super);\n  function DayTimeCols() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.buildDayRanges = memoize(buildDayRanges);\n    _this.slicer = new DayTimeColsSlicer();\n    _this.timeColsRef = createRef();\n    _this.handleRootEl = function (rootEl) {\n      if (rootEl) {\n        _this.context.registerInteractiveComponent(_this, {\n          el: rootEl\n        });\n      } else {\n        _this.context.unregisterInteractiveComponent(_this);\n      }\n    };\n    return _this;\n  }\n  DayTimeCols.prototype.render = function () {\n    var _this = this;\n    var _a = this,\n      props = _a.props,\n      context = _a.context;\n    var dateProfile = props.dateProfile,\n      dayTableModel = props.dayTableModel;\n    var isNowIndicator = context.options.nowIndicator;\n    var dayRanges = this.buildDayRanges(dayTableModel, dateProfile, context.dateEnv);\n    // give it the first row of cells\n    // TODO: would move this further down hierarchy, but sliceNowDate needs it\n    return createElement(NowTimer, {\n      unit: isNowIndicator ? 'minute' : 'day'\n    }, function (nowDate, todayRange) {\n      return createElement(TimeCols, __assign({\n        ref: _this.timeColsRef,\n        rootElRef: _this.handleRootEl\n      }, _this.slicer.sliceProps(props, dateProfile, null, context, dayRanges), {\n        forPrint: props.forPrint,\n        axis: props.axis,\n        dateProfile: dateProfile,\n        slatMetas: props.slatMetas,\n        slotDuration: props.slotDuration,\n        cells: dayTableModel.cells[0],\n        tableColGroupNode: props.tableColGroupNode,\n        tableMinWidth: props.tableMinWidth,\n        clientWidth: props.clientWidth,\n        clientHeight: props.clientHeight,\n        expandRows: props.expandRows,\n        nowDate: nowDate,\n        nowIndicatorSegs: isNowIndicator && _this.slicer.sliceNowDate(nowDate, context, dayRanges),\n        todayRange: todayRange,\n        onScrollTopRequest: props.onScrollTopRequest,\n        onSlatCoords: props.onSlatCoords\n      }));\n    });\n  };\n  DayTimeCols.prototype.queryHit = function (positionLeft, positionTop) {\n    var rawHit = this.timeColsRef.current.positionToHit(positionLeft, positionTop);\n    if (rawHit) {\n      return {\n        component: this,\n        dateSpan: rawHit.dateSpan,\n        dayEl: rawHit.dayEl,\n        rect: {\n          left: rawHit.relativeRect.left,\n          right: rawHit.relativeRect.right,\n          top: rawHit.relativeRect.top,\n          bottom: rawHit.relativeRect.bottom\n        },\n        layer: 0\n      };\n    }\n  };\n  return DayTimeCols;\n}(DateComponent);\nfunction buildDayRanges(dayTableModel, dateProfile, dateEnv) {\n  var ranges = [];\n  for (var _i = 0, _a = dayTableModel.headerDates; _i < _a.length; _i++) {\n    var date = _a[_i];\n    ranges.push({\n      start: dateEnv.add(date, dateProfile.slotMinTime),\n      end: dateEnv.add(date, dateProfile.slotMaxTime)\n    });\n  }\n  return ranges;\n}\nvar DayTimeColsSlicer = /** @class */function (_super) {\n  __extends(DayTimeColsSlicer, _super);\n  function DayTimeColsSlicer() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  DayTimeColsSlicer.prototype.sliceRange = function (range, dayRanges) {\n    var segs = [];\n    for (var col = 0; col < dayRanges.length; col++) {\n      var segRange = intersectRanges(range, dayRanges[col]);\n      if (segRange) {\n        segs.push({\n          start: segRange.start,\n          end: segRange.end,\n          isStart: segRange.start.valueOf() === range.start.valueOf(),\n          isEnd: segRange.end.valueOf() === range.end.valueOf(),\n          col: col\n        });\n      }\n    }\n    return segs;\n  };\n  return DayTimeColsSlicer;\n}(Slicer);\nvar DayTimeColsView = /** @class */function (_super) {\n  __extends(DayTimeColsView, _super);\n  function DayTimeColsView() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.buildTimeColsModel = memoize(buildTimeColsModel);\n    _this.buildSlatMetas = memoize(buildSlatMetas);\n    return _this;\n  }\n  DayTimeColsView.prototype.render = function () {\n    var _this = this;\n    var _a = this.context,\n      options = _a.options,\n      dateEnv = _a.dateEnv,\n      dateProfileGenerator = _a.dateProfileGenerator;\n    var props = this.props;\n    var dateProfile = props.dateProfile;\n    var dayTableModel = this.buildTimeColsModel(dateProfile, dateProfileGenerator);\n    var splitProps = this.allDaySplitter.splitProps(props);\n    var slatMetas = this.buildSlatMetas(dateProfile.slotMinTime, dateProfile.slotMaxTime, options.slotLabelInterval, options.slotDuration, dateEnv);\n    var dayMinWidth = options.dayMinWidth;\n    var hasAttachedAxis = !dayMinWidth;\n    var hasDetachedAxis = dayMinWidth;\n    var headerContent = options.dayHeaders && createElement(DayHeader, {\n      dates: dayTableModel.headerDates,\n      dateProfile: dateProfile,\n      datesRepDistinctDays: true,\n      renderIntro: hasAttachedAxis ? this.renderHeadAxis : null\n    });\n    var allDayContent = options.allDaySlot !== false && function (contentArg) {\n      return createElement(DayTable, __assign({}, splitProps['allDay'], {\n        dateProfile: dateProfile,\n        dayTableModel: dayTableModel,\n        nextDayThreshold: options.nextDayThreshold,\n        tableMinWidth: contentArg.tableMinWidth,\n        colGroupNode: contentArg.tableColGroupNode,\n        renderRowIntro: hasAttachedAxis ? _this.renderTableRowAxis : null,\n        showWeekNumbers: false,\n        expandRows: false,\n        headerAlignElRef: _this.headerElRef,\n        clientWidth: contentArg.clientWidth,\n        clientHeight: contentArg.clientHeight,\n        forPrint: props.forPrint\n      }, _this.getAllDayMaxEventProps()));\n    };\n    var timeGridContent = function timeGridContent(contentArg) {\n      return createElement(DayTimeCols, __assign({}, splitProps['timed'], {\n        dayTableModel: dayTableModel,\n        dateProfile: dateProfile,\n        axis: hasAttachedAxis,\n        slotDuration: options.slotDuration,\n        slatMetas: slatMetas,\n        forPrint: props.forPrint,\n        tableColGroupNode: contentArg.tableColGroupNode,\n        tableMinWidth: contentArg.tableMinWidth,\n        clientWidth: contentArg.clientWidth,\n        clientHeight: contentArg.clientHeight,\n        onSlatCoords: _this.handleSlatCoords,\n        expandRows: contentArg.expandRows,\n        onScrollTopRequest: _this.handleScrollTopRequest\n      }));\n    };\n    return hasDetachedAxis ? this.renderHScrollLayout(headerContent, allDayContent, timeGridContent, dayTableModel.colCnt, dayMinWidth, slatMetas, this.state.slatCoords) : this.renderSimpleLayout(headerContent, allDayContent, timeGridContent);\n  };\n  return DayTimeColsView;\n}(TimeColsView);\nfunction buildTimeColsModel(dateProfile, dateProfileGenerator) {\n  var daySeries = new DaySeriesModel(dateProfile.renderRange, dateProfileGenerator);\n  return new DayTableModel(daySeries, false);\n}\nvar OPTION_REFINERS = {\n  allDaySlot: Boolean\n};\nvar main = createPlugin({\n  initialView: 'timeGridWeek',\n  optionRefiners: OPTION_REFINERS,\n  views: {\n    timeGrid: {\n      component: DayTimeColsView,\n      usesMinMaxTime: true,\n      allDaySlot: true,\n      slotDuration: '00:30:00',\n      slotEventOverlap: true // a bad name. confused with overlap/constraint system\n    },\n\n    timeGridDay: {\n      type: 'timeGrid',\n      duration: {\n        days: 1\n      }\n    },\n    timeGridWeek: {\n      type: 'timeGrid',\n      duration: {\n        weeks: 1\n      }\n    }\n  }\n});\nexport default main;\nexport { DayTimeCols, DayTimeColsSlicer, DayTimeColsView, TimeCols, TimeColsSlatsCoords, TimeColsView, buildDayRanges, buildSlatMetas, buildTimeColsModel };","map":{"version":3,"sources":["src/AllDaySplitter.ts","src/TimeColsSlatsCoords.ts","src/TimeColsSlats.tsx","src/TimeColsView.tsx","src/TimeColsSeg.ts","src/event-placement.ts","src/TimeColEvent.tsx","src/TimeCol.tsx","src/TimeColsContent.tsx","src/TimeCols.tsx","src/DayTimeCols.tsx","src/DayTimeColsView.tsx","src/options.ts","src/main.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  Splitter,\n  hasBgRendering,\n  EventDef,\n  DateSpan\n} from '@fullcalendar/common'\n\nexport class AllDaySplitter extends Splitter {\n\n  getKeyInfo() {\n    return {\n      allDay: {},\n      timed: {}\n    }\n  }\n\n  getKeysForDateSpan(dateSpan: DateSpan): string[] {\n    if (dateSpan.allDay) {\n      return [ 'allDay' ]\n    } else {\n      return [ 'timed' ]\n    }\n  }\n\n  getKeysForEventDef(eventDef: EventDef): string[] {\n    if (!eventDef.allDay) {\n      return [ 'timed' ]\n    } else if (hasBgRendering(eventDef)) {\n      return [ 'timed', 'allDay' ]\n    } else {\n      return [ 'allDay' ]\n    }\n  }\n\n}\n","import { PositionCache, DateMarker, startOfDay, createDuration, asRoughMs, DateProfile, Duration, rangeContainsMarker } from '@fullcalendar/common'\nimport { TimeSlatMeta } from './TimeColsSlats'\n\n\nexport class TimeColsSlatsCoords {\n\n  constructor(\n    public positions: PositionCache,\n    private dateProfile: DateProfile,\n    private slatMetas: TimeSlatMeta[]\n  ) {\n  }\n\n\n  safeComputeTop(date: DateMarker) { // TODO: DRY with computeDateTop\n    let { dateProfile } = this\n\n    if (rangeContainsMarker(dateProfile.currentRange, date)) {\n      let startOfDayDate = startOfDay(date)\n      let timeMs = date.valueOf() - startOfDayDate.valueOf()\n\n      if (\n        timeMs >= asRoughMs(dateProfile.slotMinTime) &&\n        timeMs < asRoughMs(dateProfile.slotMaxTime)\n      ) {\n        return this.computeTimeTop(createDuration(timeMs))\n      }\n    }\n  }\n\n\n  // Computes the top coordinate, relative to the bounds of the grid, of the given date.\n  // A `startOfDayDate` must be given for avoiding ambiguity over how to treat midnight.\n  computeDateTop(when: DateMarker, startOfDayDate?: DateMarker) {\n    if (!startOfDayDate) {\n      startOfDayDate = startOfDay(when)\n    }\n    return this.computeTimeTop(createDuration(when.valueOf() - startOfDayDate.valueOf()))\n  }\n\n\n  // Computes the top coordinate, relative to the bounds of the grid, of the given time (a Duration).\n  // This is a makeshify way to compute the time-top. Assumes all slatMetas dates are uniform.\n  // Eventually allow computation with arbirary slat dates.\n  computeTimeTop(duration: Duration): number {\n    let { positions, dateProfile, slatMetas } = this\n    let len = positions.els.length\n    let slotDurationMs = slatMetas[1].date.valueOf() - slatMetas[0].date.valueOf() // we assume dates are uniform\n    let slatCoverage = (duration.milliseconds - asRoughMs(dateProfile.slotMinTime)) / slotDurationMs // floating-point value of # of slots covered\n    let slatIndex\n    let slatRemainder\n\n    // compute a floating-point number for how many slats should be progressed through.\n    // from 0 to number of slats (inclusive)\n    // constrained because slotMinTime/slotMaxTime might be customized.\n    slatCoverage = Math.max(0, slatCoverage)\n    slatCoverage = Math.min(len, slatCoverage)\n\n    // an integer index of the furthest whole slat\n    // from 0 to number slats (*exclusive*, so len-1)\n    slatIndex = Math.floor(slatCoverage)\n    slatIndex = Math.min(slatIndex, len - 1)\n\n    // how much further through the slatIndex slat (from 0.0-1.0) must be covered in addition.\n    // could be 1.0 if slatCoverage is covering *all* the slots\n    slatRemainder = slatCoverage - slatIndex\n\n    return positions.tops[slatIndex] +\n      positions.getHeight(slatIndex) * slatRemainder\n  }\n\n}\n","import {\n  createElement, VNode,\n  BaseComponent,\n  ViewContext,\n  createDuration,\n  asRoughMs,\n  formatIsoTimeString,\n  addDurations,\n  wholeDivideDurations,\n  Duration,\n  createFormatter,\n  RefMap,\n  CssDimValue,\n  createRef,\n  PositionCache,\n  DateMarker,\n  DateEnv,\n  ViewContextType,\n  RenderHook,\n  DateProfile,\n  SlotLabelContentArg,\n  SlotLaneContentArg\n} from '@fullcalendar/common'\nimport { TimeColsSlatsCoords } from './TimeColsSlatsCoords'\n\n\nexport interface TimeColsSlatsProps extends TimeColsSlatsContentProps {\n  dateProfile: DateProfile\n  clientWidth: number | null\n  minHeight: CssDimValue\n  tableMinWidth: CssDimValue\n  tableColGroupNode: VNode\n  onCoords?: (coords: TimeColsSlatsCoords | null) => void\n}\n\ninterface TimeColsSlatsContentProps {\n  axis: boolean\n  slatMetas: TimeSlatMeta[]\n}\n\n\n// potential nice values for the slot-duration and interval-duration\n// from largest to smallest\nconst STOCK_SUB_DURATIONS = [\n  { hours: 1 },\n  { minutes: 30 },\n  { minutes: 15 },\n  { seconds: 30 },\n  { seconds: 15 }\n]\n\n/*\nfor the horizontal \"slats\" that run width-wise. Has a time axis on a side. Depends on RTL.\n*/\n\n\nexport class TimeColsSlats extends BaseComponent<TimeColsSlatsProps> {\n\n  private rootElRef = createRef<HTMLDivElement>()\n  private slatElRefs = new RefMap<HTMLTableRowElement>()\n\n\n  render() {\n    let { props, context } = this\n\n    return (\n      <div className='fc-timegrid-slots' ref={this.rootElRef}>\n        <table\n          className={context.theme.getClass('table')}\n          style={{\n            minWidth: props.tableMinWidth,\n            width: props.clientWidth,\n            height: props.minHeight\n          }}\n        >\n          {props.tableColGroupNode /* relies on there only being a single <col> for the axis */}\n          <TimeColsSlatsBody\n            slatElRefs={this.slatElRefs}\n            axis={props.axis}\n            slatMetas={props.slatMetas}\n          />\n        </table>\n      </div>\n    )\n  }\n\n\n  componentDidMount() {\n    this.updateSizing()\n  }\n\n\n  componentDidUpdate() {\n    this.updateSizing()\n  }\n\n\n  componentWillUnmount() {\n    if (this.props.onCoords) {\n      this.props.onCoords(null)\n    }\n  }\n\n\n  updateSizing() {\n    let { props } = this\n\n    if (\n      props.onCoords &&\n      props.clientWidth !== null // means sizing has stabilized\n    ) {\n      let rootEl = this.rootElRef.current\n\n      if (rootEl.offsetHeight) { // not hidden by css\n        props.onCoords(\n          new TimeColsSlatsCoords(\n            new PositionCache(\n              this.rootElRef.current,\n              collectSlatEls(this.slatElRefs.currentMap, props.slatMetas),\n              false,\n              true // vertical\n            ),\n            this.props.dateProfile,\n            props.slatMetas\n          )\n        )\n      }\n    }\n  }\n\n}\n\n\nfunction collectSlatEls(elMap: { [key: string]: HTMLElement }, slatMetas: TimeSlatMeta[]) {\n  return slatMetas.map((slatMeta) => elMap[slatMeta.key])\n}\n\n\nexport interface TimeColsSlatsBodyProps {\n  axis: boolean\n  slatMetas: TimeSlatMeta[]\n  slatElRefs: RefMap<HTMLTableRowElement>\n}\n\n\nexport class TimeColsSlatsBody extends BaseComponent<TimeColsSlatsBodyProps> {\n\n  render() {\n    let { props, context } = this\n    let { options } = context\n    let { slatElRefs } = props\n\n    return (\n      <tbody>\n        {props.slatMetas.map((slatMeta, i) => {\n          let hookProps: SlotLaneContentArg = {\n            time: slatMeta.time,\n            date: context.dateEnv.toDate(slatMeta.date),\n            view: context.viewApi\n          }\n\n          let classNames = [\n            'fc-timegrid-slot',\n            'fc-timegrid-slot-lane',\n            slatMeta.isLabeled ? '' : 'fc-timegrid-slot-minor'\n          ]\n\n          return (\n            <tr\n              key={slatMeta.key}\n              ref={slatElRefs.createRef(slatMeta.key)}\n            >\n              {props.axis &&\n                <TimeColsAxisCell {...slatMeta} />\n              }\n              <RenderHook\n                hookProps={hookProps}\n                classNames={options.slotLaneClassNames}\n                content={options.slotLaneContent}\n                didMount={options.slotLaneDidMount}\n                willUnmount={options.slotLaneWillUnmount}\n              >\n                {(rootElRef, customClassNames, innerElRef, innerContent) => (\n                  <td\n                    ref={rootElRef}\n                    className={classNames.concat(customClassNames).join(' ')}\n                    data-time={slatMeta.isoTimeStr}\n                  >{innerContent}</td>\n                )}\n              </RenderHook>\n            </tr>\n          )\n        })}\n      </tbody>\n    )\n  }\n\n}\n\n\nconst DEFAULT_SLAT_LABEL_FORMAT = createFormatter({\n  hour: 'numeric',\n  minute: '2-digit',\n  omitZeroMinute: true,\n  meridiem: 'short'\n})\n\nexport function TimeColsAxisCell(props: TimeSlatMeta) {\n  let classNames = [\n    'fc-timegrid-slot',\n    'fc-timegrid-slot-label',\n    props.isLabeled ? 'fc-scrollgrid-shrink' : 'fc-timegrid-slot-minor'\n  ]\n\n  return (\n    <ViewContextType.Consumer>\n      {(context: ViewContext) => {\n\n        if (!props.isLabeled) {\n          return (\n            <td className={classNames.join(' ')} data-time={props.isoTimeStr} />\n          )\n\n        } else {\n          let { dateEnv, options, viewApi } = context\n\n          let labelFormat = // TODO: fully pre-parse\n            options.slotLabelFormat == null ? DEFAULT_SLAT_LABEL_FORMAT :\n            Array.isArray(options.slotLabelFormat) ? createFormatter(options.slotLabelFormat[0]) :\n            createFormatter(options.slotLabelFormat)\n\n          let hookProps: SlotLabelContentArg = {\n            time: props.time,\n            date: dateEnv.toDate(props.date),\n            view: viewApi,\n            text: dateEnv.format(props.date, labelFormat)\n          }\n\n          return (\n            <RenderHook<SlotLabelContentArg> // needed?\n              hookProps={hookProps}\n              classNames={options.slotLabelClassNames}\n              content={options.slotLabelContent}\n              defaultContent={renderInnerContent}\n              didMount={options.slotLabelDidMount}\n              willUnmount={options.slotLabelWillUnmount}\n            >\n              {(rootElRef, customClassNames, innerElRef, innerContent) => (\n                <td ref={rootElRef} className={classNames.concat(customClassNames).join(' ')} data-time={props.isoTimeStr}>\n                  <div className='fc-timegrid-slot-label-frame fc-scrollgrid-shrink-frame'>\n                    <div className='fc-timegrid-slot-label-cushion fc-scrollgrid-shrink-cushion' ref={innerElRef}>\n                      {innerContent}\n                    </div>\n                  </div>\n                </td>\n              )}\n            </RenderHook>\n          )\n        }\n      }}\n    </ViewContextType.Consumer>\n  )\n}\n\n\nfunction renderInnerContent(props) { // TODO: add types\n  return props.text\n}\n\n\nexport interface TimeSlatMeta {\n  date: DateMarker\n  time: Duration\n  key: string\n  isoTimeStr: string\n  isLabeled: boolean\n}\n\nexport function buildSlatMetas(slotMinTime: Duration, slotMaxTime: Duration, explicitLabelInterval: Duration | null, slotDuration: Duration, dateEnv: DateEnv) {\n  let dayStart = new Date(0)\n  let slatTime = slotMinTime\n  let slatIterator = createDuration(0)\n  let labelInterval = explicitLabelInterval || computeLabelInterval(slotDuration)\n  let metas: TimeSlatMeta[] = []\n\n  while (asRoughMs(slatTime) < asRoughMs(slotMaxTime)) {\n    let date = dateEnv.add(dayStart, slatTime)\n    let isLabeled = wholeDivideDurations(slatIterator, labelInterval) !== null\n\n    metas.push({\n      date,\n      time: slatTime,\n      key: date.toISOString(), // we can't use the isoTimeStr for uniqueness when minTime/maxTime beyone 0h/24h\n      isoTimeStr: formatIsoTimeString(date),\n      isLabeled\n    })\n\n    slatTime = addDurations(slatTime, slotDuration)\n    slatIterator = addDurations(slatIterator, slotDuration)\n  }\n\n  return metas\n}\n\n\n// Computes an automatic value for slotLabelInterval\nfunction computeLabelInterval(slotDuration) {\n  let i\n  let labelInterval\n  let slotsPerLabel\n\n  // find the smallest stock label interval that results in more than one slots-per-label\n  for (i = STOCK_SUB_DURATIONS.length - 1; i >= 0; i--) {\n    labelInterval = createDuration(STOCK_SUB_DURATIONS[i])\n    slotsPerLabel = wholeDivideDurations(labelInterval, slotDuration)\n    if (slotsPerLabel !== null && slotsPerLabel > 1) {\n      return labelInterval\n    }\n  }\n\n  return slotDuration // fall back\n}\n","import {\n  createElement, createRef,\n  diffDays,\n  SimpleScrollGridSection,\n  VNode,\n  SimpleScrollGrid,\n  ChunkContentCallbackArgs,\n  ScrollGridSectionConfig,\n  BaseComponent,\n  buildNavLinkData,\n  ViewRoot,\n  WeekNumberRoot,\n  RenderHook,\n  DateComponent,\n  ViewProps,\n  RefObject,\n  renderScrollShim,\n  getStickyHeaderDates,\n  getStickyFooterScrollbar,\n  createFormatter,\n  AllDayContentArg,\n  CssDimValue,\n  NowTimer,\n  DateMarker,\n  NowIndicatorRoot\n} from '@fullcalendar/common'\nimport { AllDaySplitter } from './AllDaySplitter'\nimport { TimeSlatMeta, TimeColsAxisCell } from './TimeColsSlats'\nimport { TimeColsSlatsCoords } from './TimeColsSlatsCoords'\n\n\nconst DEFAULT_WEEK_NUM_FORMAT = createFormatter({ week: 'short' })\nconst AUTO_ALL_DAY_MAX_EVENT_ROWS = 5\n\n\n/* An abstract class for all timegrid-related views. Displays one more columns with time slots running vertically.\n----------------------------------------------------------------------------------------------------------------------*/\n// Is a manager for the TimeCols subcomponent and possibly the DayGrid subcomponent (if allDaySlot is on).\n// Responsible for managing width/height.\n\ninterface TimeColsViewState {\n  slatCoords: TimeColsSlatsCoords | null\n}\n\nexport abstract class TimeColsView extends DateComponent<ViewProps, TimeColsViewState> {\n\n  protected allDaySplitter = new AllDaySplitter() // for use by subclasses\n\n  protected headerElRef: RefObject<HTMLTableCellElement> = createRef<HTMLTableCellElement>()\n  private rootElRef: RefObject<HTMLDivElement> = createRef<HTMLDivElement>()\n  private scrollerElRef: RefObject<HTMLDivElement> = createRef<HTMLDivElement>()\n\n  state = {\n    slatCoords: null\n  }\n\n\n  // rendering\n  // ----------------------------------------------------------------------------------------------------\n\n\n  renderSimpleLayout(\n    headerRowContent: VNode | null,\n    allDayContent: ((contentArg: ChunkContentCallbackArgs) => VNode) | null,\n    timeContent: ((contentArg: ChunkContentCallbackArgs) => VNode) | null\n  ) {\n    let { context, props } = this\n    let sections: SimpleScrollGridSection[] = []\n    let stickyHeaderDates = getStickyHeaderDates(context.options)\n\n    if (headerRowContent) {\n      sections.push({\n        type: 'header',\n        key: 'header',\n        isSticky: stickyHeaderDates,\n        chunk: {\n          elRef: this.headerElRef,\n          tableClassName: 'fc-col-header',\n          rowContent: headerRowContent\n        }\n      })\n    }\n\n    if (allDayContent) {\n      sections.push({\n        type: 'body',\n        key: 'all-day',\n        chunk: { content: allDayContent }\n      })\n      sections.push({\n        type: 'body',\n        key: 'all-day-divider',\n        outerContent: ( // TODO: rename to cellContent so don't need to define <tr>?\n          <tr className='fc-scrollgrid-section'>\n            <td\n              className={'fc-timegrid-divider ' + context.theme.getClass('tableCellShaded')}\n            />\n          </tr>\n        )\n      })\n    }\n\n    sections.push({\n      type: 'body',\n      key: 'body',\n      liquid: true,\n      expandRows: Boolean(context.options.expandRows),\n      chunk: {\n        scrollerElRef: this.scrollerElRef,\n        content: timeContent\n      }\n    })\n\n    return (\n      <ViewRoot viewSpec={context.viewSpec} elRef={this.rootElRef}>\n        {(rootElRef, classNames) => (\n          <div className={[ 'fc-timegrid' ].concat(classNames).join(' ')} ref={rootElRef}>\n            <SimpleScrollGrid\n              liquid={!props.isHeightAuto && !props.forPrint}\n              cols={[ { width: 'shrink' } ]}\n              sections={sections}\n            />\n          </div>\n        )}\n      </ViewRoot>\n    )\n  }\n\n\n  renderHScrollLayout(\n    headerRowContent: VNode | null,\n    allDayContent: ((contentArg: ChunkContentCallbackArgs) => VNode) | null,\n    timeContent: ((contentArg: ChunkContentCallbackArgs) => VNode) | null,\n    colCnt: number,\n    dayMinWidth: number,\n    slatMetas: TimeSlatMeta[],\n    slatCoords: TimeColsSlatsCoords | null // yuck\n  ) {\n    let ScrollGrid = this.context.pluginHooks.scrollGridImpl\n\n    if (!ScrollGrid) {\n      throw new Error('No ScrollGrid implementation')\n    }\n\n    let { context, props } = this\n    let stickyHeaderDates = !props.forPrint && getStickyHeaderDates(context.options)\n    let stickyFooterScrollbar = !props.forPrint && getStickyFooterScrollbar(context.options)\n    let sections: ScrollGridSectionConfig[] = []\n\n    if (headerRowContent) {\n      sections.push({\n        type: 'header',\n        key: 'header',\n        isSticky: stickyHeaderDates,\n        syncRowHeights: true,\n        chunks: [\n          {\n            key: 'axis',\n            rowContent: (arg: ChunkContentCallbackArgs) => (\n              <tr>{this.renderHeadAxis(arg.rowSyncHeights[0])}</tr>\n            )\n          },\n          {\n            key: 'cols',\n            elRef: this.headerElRef,\n            tableClassName: 'fc-col-header',\n            rowContent: headerRowContent\n          }\n        ]\n      })\n    }\n\n    if (allDayContent) {\n      sections.push({\n        type: 'body',\n        key: 'all-day',\n        syncRowHeights: true,\n        chunks: [\n          {\n            key: 'axis',\n            rowContent: (contentArg: ChunkContentCallbackArgs) => (\n              <tr>{this.renderTableRowAxis(contentArg.rowSyncHeights[0])}</tr>\n            ),\n          },\n          {\n            key: 'cols',\n            content: allDayContent\n          }\n        ]\n      })\n      sections.push({\n        key: 'all-day-divider',\n        type: 'body',\n        outerContent: ( // TODO: rename to cellContent so don't need to define <tr>?\n          <tr className='fc-scrollgrid-section'>\n            <td\n              colSpan={2}\n              className={'fc-timegrid-divider ' + context.theme.getClass('tableCellShaded')}\n            />\n          </tr>\n        )\n      })\n    }\n\n    let isNowIndicator = context.options.nowIndicator\n\n    sections.push({\n      type: 'body',\n      key: 'body',\n      liquid: true,\n      expandRows: Boolean(context.options.expandRows),\n      chunks: [\n        {\n          key: 'axis',\n          content: (arg) => {\n            // TODO: make this now-indicator arrow more DRY with TimeColsContent\n            return (\n              <div className='fc-timegrid-axis-chunk'>\n                <table>\n                  {arg.tableColGroupNode}\n                  <tbody>\n                    <TimeBodyAxis slatMetas={slatMetas} />\n                  </tbody>\n                </table>\n                <div className='fc-timegrid-now-indicator-container'>\n                  <NowTimer unit={isNowIndicator ? 'minute' : 'day' /* hacky */}>\n                    {(nowDate: DateMarker) => {\n                      let nowIndicatorTop =\n                        isNowIndicator &&\n                        slatCoords &&\n                        slatCoords.safeComputeTop(nowDate) // might return void\n\n                      if (typeof nowIndicatorTop === 'number') {\n                        return (\n                          <NowIndicatorRoot isAxis={true} date={nowDate}>\n                            {(rootElRef, classNames, innerElRef, innerContent) => (\n                              <div\n                                ref={rootElRef}\n                                className={[ 'fc-timegrid-now-indicator-arrow' ].concat(classNames).join(' ')}\n                                style={{ top: nowIndicatorTop }}\n                              >{innerContent}</div>\n                            )}\n                          </NowIndicatorRoot>\n                        )\n                      }\n                    }}\n                  </NowTimer>\n                </div>\n              </div>\n            )\n          }\n        },\n        {\n          key: 'cols',\n          scrollerElRef: this.scrollerElRef,\n          content: timeContent\n        }\n      ]\n    })\n\n    if (stickyFooterScrollbar) {\n      sections.push({\n        key: 'footer',\n        type: 'footer',\n        isSticky: true,\n        chunks: [\n          {\n            key: 'axis',\n            content: renderScrollShim\n          },\n          {\n            key: 'cols',\n            content: renderScrollShim\n          }\n        ]\n      })\n    }\n\n    return (\n      <ViewRoot viewSpec={context.viewSpec} elRef={this.rootElRef}>\n        {(rootElRef, classNames) => (\n          <div className={[ 'fc-timegrid' ].concat(classNames).join(' ')} ref={rootElRef}>\n            <ScrollGrid\n              liquid={!props.isHeightAuto && !props.forPrint}\n              colGroups={[\n                { width: 'shrink', cols: [ { width: 'shrink' } ] }, // TODO: allow no specify cols\n                { cols: [ { span: colCnt, minWidth: dayMinWidth } ] }\n              ]}\n              sections={sections}\n            />\n          </div>\n        )}\n      </ViewRoot>\n    )\n  }\n\n\n  handleScrollTopRequest = (scrollTop: number) => {\n    let scrollerEl = this.scrollerElRef.current\n\n    if (scrollerEl) { // TODO: not sure how this could ever be null. weirdness with the reducer\n      scrollerEl.scrollTop = scrollTop\n    }\n  }\n\n\n  /* Dimensions\n  ------------------------------------------------------------------------------------------------------------------*/\n\n\n  getAllDayMaxEventProps() {\n    let { dayMaxEvents, dayMaxEventRows } = this.context.options\n\n    if (dayMaxEvents === true || dayMaxEventRows === true) { // is auto?\n      dayMaxEvents = undefined\n      dayMaxEventRows = AUTO_ALL_DAY_MAX_EVENT_ROWS // make sure \"auto\" goes to a real number\n    }\n\n    return { dayMaxEvents, dayMaxEventRows }\n  }\n\n\n\n  /* Header Render Methods\n  ------------------------------------------------------------------------------------------------------------------*/\n\n\n  renderHeadAxis = (frameHeight: CssDimValue = '') => {\n    let { options } = this.context\n    let { dateProfile } = this.props\n    let range = dateProfile.renderRange\n    let dayCnt = diffDays(range.start, range.end)\n\n    let navLinkAttrs = (options.navLinks && dayCnt === 1) // only do in day views (to avoid doing in week views that dont need it)\n      ? { 'data-navlink': buildNavLinkData(range.start, 'week'), tabIndex: 0 }\n      : {}\n\n    if (options.weekNumbers) {\n      return (\n        <WeekNumberRoot date={range.start} defaultFormat={DEFAULT_WEEK_NUM_FORMAT}>\n          {(rootElRef, classNames, innerElRef, innerContent) => (\n            <th ref={rootElRef} className={[\n              'fc-timegrid-axis',\n              'fc-scrollgrid-shrink'\n            ].concat(classNames).join(' ')}>\n              <div\n                className='fc-timegrid-axis-frame fc-scrollgrid-shrink-frame fc-timegrid-axis-frame-liquid'\n                style={{ height: frameHeight }}\n              >\n                <a\n                  ref={innerElRef}\n                  className='fc-timegrid-axis-cushion fc-scrollgrid-shrink-cushion'\n                  {...navLinkAttrs}\n                >\n                  {innerContent}\n                </a>\n              </div>\n            </th>\n          )}\n        </WeekNumberRoot>\n      )\n    }\n\n    return (\n      <th className='fc-timegrid-axis'>\n        <div className='fc-timegrid-axis-frame' style={{ height: frameHeight }}></div>\n      </th>\n    )\n  }\n\n\n  /* Table Component Render Methods\n  ------------------------------------------------------------------------------------------------------------------*/\n\n\n  // only a one-way height sync. we don't send the axis inner-content height to the DayGrid,\n  // but DayGrid still needs to have classNames on inner elements in order to measure.\n  renderTableRowAxis = (rowHeight?: number) => {\n    let { options, viewApi } = this.context\n    let hookProps: AllDayContentArg = {\n      text: options.allDayText,\n      view: viewApi\n    }\n\n    return (\n      // TODO: make reusable hook. used in list view too\n      <RenderHook<AllDayContentArg>\n        hookProps={hookProps}\n        classNames={options.allDayClassNames}\n        content={options.allDayContent}\n        defaultContent={renderAllDayInner}\n        didMount={options.allDayDidMount}\n        willUnmount={options.allDayWillUnmount}\n      >\n        {(rootElRef, classNames, innerElRef, innerContent) => (\n          <td ref={rootElRef} className={[\n            'fc-timegrid-axis',\n            'fc-scrollgrid-shrink'\n          ].concat(classNames).join(' ')}>\n            <div className={'fc-timegrid-axis-frame fc-scrollgrid-shrink-frame' + (rowHeight == null ? ' fc-timegrid-axis-frame-liquid' : '')} style={{ height: rowHeight }}>\n              <span className='fc-timegrid-axis-cushion fc-scrollgrid-shrink-cushion' ref={innerElRef}>\n                {innerContent}\n              </span>\n            </div>\n          </td>\n        )}\n      </RenderHook>\n    )\n  }\n\n\n  handleSlatCoords = (slatCoords: TimeColsSlatsCoords) => {\n    this.setState({ slatCoords })\n  }\n\n}\n\nfunction renderAllDayInner(hookProps) {\n  return hookProps.text\n}\n\n\n/* Thin Axis\n------------------------------------------------------------------------------------------------------------------*/\n\ninterface TimeBodyAxisProps {\n  slatMetas: TimeSlatMeta[]\n}\n\nclass TimeBodyAxis extends BaseComponent<TimeBodyAxisProps> { // just <tr> content\n\n  render() {\n    return this.props.slatMetas.map((slatMeta: TimeSlatMeta) => (\n      <tr key={slatMeta.key}>\n        <TimeColsAxisCell {...slatMeta} />\n      </tr>\n    ))\n  }\n\n}\n","import { DateMarker, Seg, EventSegUiInteractionState } from '@fullcalendar/common'\n\n\n// JUST A DATA STRUCTURE, not a component\n\n\nexport interface TimeColsSeg extends Seg {\n  col: number\n  start: DateMarker\n  end: DateMarker\n}\n\n\nexport function splitSegsByCol(segs: TimeColsSeg[] | null, colCnt: number) { // can be given null/undefined!\n  let segsByCol: TimeColsSeg[][] = []\n  let i\n\n  for (i = 0; i < colCnt; i++) {\n    segsByCol.push([])\n  }\n\n  if (segs) {\n    for (i = 0; i < segs.length; i++) {\n      segsByCol[segs[i].col].push(segs[i])\n    }\n  }\n\n  return segsByCol\n}\n\n\nexport function splitInteractionByCol(ui: EventSegUiInteractionState | null, colCnt: number) {\n  let byRow: EventSegUiInteractionState[] = []\n\n  if (!ui) {\n    for (let i = 0; i < colCnt; i++) {\n      byRow[i] = null\n    }\n\n  } else {\n    for (let i = 0; i < colCnt; i++) {\n      byRow[i] = {\n        affectedInstances: ui.affectedInstances,\n        isEvent: ui.isEvent,\n        segs: []\n      }\n    }\n\n    for (let seg of ui.segs) {\n      byRow[seg.col].segs.push(seg)\n    }\n  }\n\n  return byRow\n}\n","import {\n  Seg, DateMarker, buildSegCompareObj, compareByFieldSpecs, sortEventSegs, OrderSpec, EventApi\n} from '@fullcalendar/common'\nimport { TimeColsSlatsCoords } from './TimeColsSlatsCoords'\n\n\n// UNFORTUNATELY, assigns results to the top/bottom/level/forwardCoord/backwardCoord props of the actual segs.\n// TODO: return hash (by instanceId) of results\n\n\nexport function computeSegCoords(segs: Seg[], dayDate: DateMarker, slatCoords: TimeColsSlatsCoords, eventMinHeight: number, eventOrderSpecs: OrderSpec<EventApi>[]) {\n  computeSegVerticals(segs, dayDate, slatCoords, eventMinHeight)\n  return computeSegHorizontals(segs, eventOrderSpecs) // requires top/bottom from computeSegVerticals\n}\n\n\n// For each segment in an array, computes and assigns its top and bottom properties\nexport function computeSegVerticals(segs: Seg[], dayDate: DateMarker, slatCoords: TimeColsSlatsCoords, eventMinHeight: number) {\n  for (let seg of segs) {\n    seg.top = slatCoords.computeDateTop(seg.start, dayDate)\n    seg.bottom = Math.max(\n      seg.top + (eventMinHeight || 0), // yuck\n      slatCoords.computeDateTop(seg.end, dayDate)\n    )\n  }\n}\n\n\n// Given an array of segments that are all in the same column, sets the backwardCoord and forwardCoord on each.\n// Assumed the segs are already ordered.\n// NOTE: Also reorders the given array by date!\nfunction computeSegHorizontals(segs: Seg[], eventOrderSpecs: OrderSpec<EventApi>[]) {\n\n  // IMPORTANT TO CLEAR OLD RESULTS :(\n  for (let seg of segs) {\n    seg.level = null\n    seg.forwardCoord = null\n    seg.backwardCoord = null\n    seg.forwardPressure = null\n  }\n\n  segs = sortEventSegs(segs, eventOrderSpecs)\n\n  let level0\n  let levels = buildSlotSegLevels(segs)\n  computeForwardSlotSegs(levels)\n\n  if ((level0 = levels[0])) {\n\n    for (let seg of level0) {\n      computeSlotSegPressures(seg)\n    }\n\n    for (let seg of level0) {\n      computeSegForwardBack(seg, 0, 0, eventOrderSpecs)\n    }\n  }\n\n  return segs\n}\n\n\n// Builds an array of segments \"levels\". The first level will be the leftmost tier of segments if the calendar is\n// left-to-right, or the rightmost if the calendar is right-to-left. Assumes the segments are already ordered by date.\nfunction buildSlotSegLevels(segs: Seg[]) {\n  let levels = []\n  let i\n  let seg\n  let j\n\n  for (i = 0; i < segs.length; i++) {\n    seg = segs[i]\n\n    // go through all the levels and stop on the first level where there are no collisions\n    for (j = 0; j < levels.length; j++) {\n      if (!computeSlotSegCollisions(seg, levels[j]).length) {\n        break\n      }\n    }\n\n    seg.level = j\n\n    ;(levels[j] || (levels[j] = [])).push(seg)\n  }\n\n  return levels\n}\n\n\n// Find all the segments in `otherSegs` that vertically collide with `seg`.\n// Append into an optionally-supplied `results` array and return.\nfunction computeSlotSegCollisions(seg: Seg, otherSegs: Seg[], results= []) {\n\n  for (let i = 0; i < otherSegs.length; i++) {\n    if (isSlotSegCollision(seg, otherSegs[i])) {\n      results.push(otherSegs[i])\n    }\n  }\n\n  return results\n}\n\n\n// Do these segments occupy the same vertical space?\nfunction isSlotSegCollision(seg1: Seg, seg2: Seg) {\n  return seg1.bottom > seg2.top && seg1.top < seg2.bottom\n}\n\n\n// For every segment, figure out the other segments that are in subsequent\n// levels that also occupy the same vertical space. Accumulate in seg.forwardSegs\nfunction computeForwardSlotSegs(levels) {\n  let i\n  let level\n  let j\n  let seg\n  let k\n\n  for (i = 0; i < levels.length; i++) {\n    level = levels[i]\n\n    for (j = 0; j < level.length; j++) {\n      seg = level[j]\n\n      seg.forwardSegs = []\n      for (k = i + 1; k < levels.length; k++) {\n        computeSlotSegCollisions(seg, levels[k], seg.forwardSegs)\n      }\n    }\n  }\n}\n\n\n// Figure out which path forward (via seg.forwardSegs) results in the longest path until\n// the furthest edge is reached. The number of segments in this path will be seg.forwardPressure\nfunction computeSlotSegPressures(seg: Seg) {\n  let forwardSegs = seg.forwardSegs\n  let forwardPressure = 0\n  let i\n  let forwardSeg\n\n  if (seg.forwardPressure == null) { // not already computed\n\n    for (i = 0; i < forwardSegs.length; i++) {\n      forwardSeg = forwardSegs[i]\n\n      // figure out the child's maximum forward path\n      computeSlotSegPressures(forwardSeg)\n\n      // either use the existing maximum, or use the child's forward pressure\n      // plus one (for the forwardSeg itself)\n      forwardPressure = Math.max(\n        forwardPressure,\n        1 + forwardSeg.forwardPressure\n      )\n    }\n\n    seg.forwardPressure = forwardPressure\n  }\n}\n\n\n// Calculate seg.forwardCoord and seg.backwardCoord for the segment, where both values range\n// from 0 to 1. If the calendar is left-to-right, the seg.backwardCoord maps to \"left\" and\n// seg.forwardCoord maps to \"right\" (via percentage). Vice-versa if the calendar is right-to-left.\n//\n// The segment might be part of a \"series\", which means consecutive segments with the same pressure\n// who's width is unknown until an edge has been hit. `seriesBackwardPressure` is the number of\n// segments behind this one in the current series, and `seriesBackwardCoord` is the starting\n// coordinate of the first segment in the series.\nfunction computeSegForwardBack(seg: Seg, seriesBackwardPressure, seriesBackwardCoord, eventOrderSpecs) {\n  let forwardSegs = seg.forwardSegs\n  let i\n\n  if (seg.forwardCoord == null) { // not already computed\n\n    if (!forwardSegs.length) {\n\n      // if there are no forward segments, this segment should butt up against the edge\n      seg.forwardCoord = 1\n    } else {\n\n      // sort highest pressure first\n      sortForwardSegs(forwardSegs, eventOrderSpecs)\n\n      // this segment's forwardCoord will be calculated from the backwardCoord of the\n      // highest-pressure forward segment.\n      computeSegForwardBack(forwardSegs[0], seriesBackwardPressure + 1, seriesBackwardCoord, eventOrderSpecs)\n      seg.forwardCoord = forwardSegs[0].backwardCoord\n    }\n\n    // calculate the backwardCoord from the forwardCoord. consider the series\n    seg.backwardCoord = seg.forwardCoord -\n      (seg.forwardCoord - seriesBackwardCoord) / // available width for series\n      (seriesBackwardPressure + 1) // # of segments in the series\n\n    // use this segment's coordinates to computed the coordinates of the less-pressurized\n    // forward segments\n    for (i = 0; i < forwardSegs.length; i++) {\n      computeSegForwardBack(forwardSegs[i], 0, seg.forwardCoord, eventOrderSpecs)\n    }\n  }\n}\n\n\nfunction sortForwardSegs(forwardSegs: Seg[], eventOrderSpecs) {\n  let objs = forwardSegs.map(buildTimeGridSegCompareObj)\n\n  let specs = [\n    // put higher-pressure first\n    { field: 'forwardPressure', order: -1 },\n    // put segments that are closer to initial edge first (and favor ones with no coords yet)\n    { field: 'backwardCoord', order: 1 }\n  ].concat(eventOrderSpecs)\n\n  objs.sort(function(obj0, obj1) {\n    return compareByFieldSpecs(obj0, obj1, specs)\n  })\n\n  return objs.map(function(c) {\n    return c._seg\n  })\n}\n\n\nfunction buildTimeGridSegCompareObj(seg: Seg): any {\n  let obj = buildSegCompareObj(seg) as any\n\n  obj.forwardPressure = seg.forwardPressure\n  obj.backwardCoord = seg.backwardCoord\n\n  return obj\n}\n","import { createElement, StandardEvent, BaseComponent, MinimalEventProps, createFormatter } from '@fullcalendar/common'\n\n\nconst DEFAULT_TIME_FORMAT = createFormatter({\n  hour: 'numeric',\n  minute: '2-digit',\n  meridiem: false\n})\n\n\nexport interface TimeColEventProps extends MinimalEventProps {\n  isCondensed: boolean\n}\n\nexport class TimeColEvent extends BaseComponent<TimeColEventProps> {\n\n  render() {\n    let classNames = [\n      'fc-timegrid-event',\n      'fc-v-event'\n    ]\n\n    if (this.props.isCondensed) {\n      classNames.push('fc-timegrid-event-condensed')\n    }\n\n    return (\n      <StandardEvent\n        {...this.props}\n        defaultTimeFormat={DEFAULT_TIME_FORMAT}\n        extraClassNames={classNames}\n      />\n    )\n  }\n\n}\n","import {\n  Ref, DateMarker, BaseComponent, createElement, EventSegUiInteractionState, Seg, getSegMeta, DateRange, Fragment, DayCellRoot, NowIndicatorRoot,\n  DayCellContent, BgEvent, renderFill, DateProfile, config, buildEventRangeKey\n} from '@fullcalendar/common'\nimport { TimeColsSeg } from './TimeColsSeg'\nimport { TimeColsSlatsCoords } from './TimeColsSlatsCoords'\nimport { computeSegCoords, computeSegVerticals } from './event-placement'\nimport { TimeColEvent } from './TimeColEvent'\n\n\nexport interface TimeColProps {\n  elRef?: Ref<HTMLTableCellElement>\n  dateProfile: DateProfile\n  date: DateMarker\n  nowDate: DateMarker\n  todayRange: DateRange\n  extraDataAttrs?: any\n  extraHookProps?: any\n  extraClassNames?: string[]\n  fgEventSegs: TimeColsSeg[]\n  bgEventSegs: TimeColsSeg[]\n  businessHourSegs: TimeColsSeg[]\n  nowIndicatorSegs: TimeColsSeg[]\n  dateSelectionSegs: TimeColsSeg[]\n  eventSelection: string\n  eventDrag: EventSegUiInteractionState | null\n  eventResize: EventSegUiInteractionState | null\n  slatCoords: TimeColsSlatsCoords\n  forPrint: boolean\n}\n\nconfig.timeGridEventCondensedHeight = 30\n\n\nexport class TimeCol extends BaseComponent<TimeColProps> {\n\n\n  render() {\n    let { props, context } = this\n    let isSelectMirror = context.options.selectMirror\n\n    let mirrorSegs: Seg[] = // yuck\n      (props.eventDrag && props.eventDrag.segs) ||\n      (props.eventResize && props.eventResize.segs) ||\n      (isSelectMirror && props.dateSelectionSegs) ||\n      []\n\n    let interactionAffectedInstances = // TODO: messy way to compute this\n      (props.eventDrag && props.eventDrag.affectedInstances) ||\n      (props.eventResize && props.eventResize.affectedInstances) ||\n      {}\n\n    return (\n      <DayCellRoot elRef={props.elRef} date={props.date} dateProfile={props.dateProfile} todayRange={props.todayRange} extraHookProps={props.extraHookProps}>\n        {(rootElRef, classNames, dataAttrs) => (\n          <td\n            ref={rootElRef}\n            className={[ 'fc-timegrid-col' ].concat(classNames, props.extraClassNames || []).join(' ')}\n            {...dataAttrs}\n            {...props.extraDataAttrs}\n          >\n            <div className='fc-timegrid-col-frame'>\n              <div className='fc-timegrid-col-bg'>\n                {this.renderFillSegs(props.businessHourSegs, 'non-business')}\n                {this.renderFillSegs(props.bgEventSegs, 'bg-event')}\n                {this.renderFillSegs(props.dateSelectionSegs, 'highlight')}\n              </div>\n              <div className='fc-timegrid-col-events'>\n                {this.renderFgSegs(\n                  props.fgEventSegs,\n                  interactionAffectedInstances\n                )}\n              </div>\n              <div className='fc-timegrid-col-events'>\n                {this.renderFgSegs(\n                  mirrorSegs as TimeColsSeg[],\n                  {},\n                  Boolean(props.eventDrag),\n                  Boolean(props.eventResize),\n                  Boolean(isSelectMirror)\n                  // TODO: pass in left/right instead of using only computeSegTopBottomCss\n                )}\n              </div>\n              <div className='fc-timegrid-now-indicator-container'>\n                {this.renderNowIndicator(props.nowIndicatorSegs)}\n              </div>\n              <TimeColMisc\n                date={props.date}\n                dateProfile={props.dateProfile}\n                todayRange={props.todayRange}\n                extraHookProps={props.extraHookProps}\n              />\n            </div>\n          </td>\n        )}\n      </DayCellRoot>\n    )\n  }\n\n\n  renderFgSegs(\n    segs: TimeColsSeg[],\n    segIsInvisible: { [instanceId: string]: any },\n    isDragging?: boolean,\n    isResizing?: boolean,\n    isDateSelecting?: boolean\n  ) {\n    let { props } = this\n\n    if (props.forPrint) {\n      return this.renderPrintFgSegs(segs)\n    } else if (props.slatCoords) {\n      return this.renderPositionedFgSegs(segs, segIsInvisible, isDragging, isResizing, isDateSelecting)\n    }\n  }\n\n\n  renderPrintFgSegs(segs: TimeColsSeg[]) {\n    let { props } = this\n\n    return segs.map((seg) => (\n      <div\n        className='fc-timegrid-event-harness'\n        key={seg.eventRange.instance.instanceId}\n      >\n        <TimeColEvent\n          seg={seg}\n          isDragging={false}\n          isResizing={false}\n          isDateSelecting={false}\n          isSelected={false}\n          isCondensed={false}\n          {...getSegMeta(seg, props.todayRange, props.nowDate)}\n        />\n      </div>\n    ))\n  }\n\n\n  renderPositionedFgSegs(\n    segs: TimeColsSeg[],\n    segIsInvisible: { [instanceId: string]: any },\n    isDragging?: boolean,\n    isResizing?: boolean,\n    isDateSelecting?: boolean\n  ) {\n    let { context, props } = this\n\n    // assigns TO THE SEGS THEMSELVES\n    // also, receives resorted array\n    segs = computeSegCoords(segs, props.date, props.slatCoords, context.options.eventMinHeight, context.options.eventOrder) as TimeColsSeg[]\n\n    return segs.map((seg) => {\n      let instanceId = seg.eventRange.instance.instanceId\n      let isMirror = isDragging || isResizing || isDateSelecting\n      let positionCss = isMirror ?\n        // will span entire column width\n        // also, won't assign z-index, which is good, fc-event-mirror will overpower other harnesses\n        { left: 0, right: 0, ...this.computeSegTopBottomCss(seg) }\n        :\n        this.computeFgSegPositionCss(seg)\n\n      return (\n        <div\n          className={'fc-timegrid-event-harness' + (seg.level > 0 ? ' fc-timegrid-event-harness-inset' : '')}\n          key={instanceId}\n          style={{\n            visibility: segIsInvisible[instanceId] ? 'hidden' : ('' as any),\n            ...positionCss\n          }}\n        >\n          <TimeColEvent\n            seg={seg}\n            isDragging={isDragging}\n            isResizing={isResizing}\n            isDateSelecting={isDateSelecting}\n            isSelected={instanceId === props.eventSelection}\n            isCondensed={(seg.bottom - seg.top) < config.timeGridEventCondensedHeight}\n            {...getSegMeta(seg, props.todayRange, props.nowDate)}\n          />\n        </div>\n      )\n    })\n  }\n\n\n  renderFillSegs(segs: TimeColsSeg[], fillType: string) {\n    let { context, props } = this\n\n    if (!props.slatCoords) { return }\n\n    // BAD: assigns TO THE SEGS THEMSELVES\n    computeSegVerticals(segs, props.date, props.slatCoords, context.options.eventMinHeight)\n\n    let children = segs.map((seg) => (\n      <div key={buildEventRangeKey(seg.eventRange)} className='fc-timegrid-bg-harness' style={this.computeSegTopBottomCss(seg)}>\n        {fillType === 'bg-event' ?\n          <BgEvent seg={seg} {...getSegMeta(seg, props.todayRange, props.nowDate)} /> :\n          renderFill(fillType)\n        }\n      </div>\n    ))\n\n    return <Fragment>{children}</Fragment>\n  }\n\n\n  renderNowIndicator(segs: TimeColsSeg[]) {\n    let { slatCoords, date } = this.props\n\n    if (!slatCoords) { return }\n\n    return segs.map((seg, i) => (\n      <NowIndicatorRoot isAxis={false} date={date} key={i /* key doesn't matter. will only ever be one */}>\n        {(rootElRef, classNames, innerElRef, innerContent) => (\n          <div\n            ref={rootElRef}\n            className={[ 'fc-timegrid-now-indicator-line' ].concat(classNames).join(' ')}\n            style={{ top: slatCoords.computeDateTop(seg.start, date) }}\n          >{innerContent}</div>\n        )}\n      </NowIndicatorRoot>\n    ))\n  }\n\n\n  computeFgSegPositionCss(seg) {\n    let { isRtl, options } = this.context\n    let shouldOverlap = options.slotEventOverlap\n    let backwardCoord = seg.backwardCoord // the left side if LTR. the right side if RTL. floating-point\n    let forwardCoord = seg.forwardCoord // the right side if LTR. the left side if RTL. floating-point\n    let left // amount of space from left edge, a fraction of the total width\n    let right // amount of space from right edge, a fraction of the total width\n\n    if (shouldOverlap) {\n      // double the width, but don't go beyond the maximum forward coordinate (1.0)\n      forwardCoord = Math.min(1, backwardCoord + (forwardCoord - backwardCoord) * 2)\n    }\n\n    if (isRtl) {\n      left = 1 - forwardCoord\n      right = backwardCoord\n    } else {\n      left = backwardCoord\n      right = 1 - forwardCoord\n    }\n\n    let props = {\n      zIndex: seg.level + 1, // convert from 0-base to 1-based\n      left: left * 100 + '%',\n      right: right * 100 + '%'\n    }\n\n    if (shouldOverlap && seg.forwardPressure) {\n      // add padding to the edge so that forward stacked events don't cover the resizer's icon\n      props[isRtl ? 'marginLeft' : 'marginRight'] = 10 * 2 // 10 is a guesstimate of the icon's width\n    }\n\n    return { ...props, ...this.computeSegTopBottomCss(seg) }\n  }\n\n\n  computeSegTopBottomCss(seg) {\n    return {\n      top: seg.top,\n      bottom: -seg.bottom\n    }\n  }\n\n}\n\n\ninterface TimeColMiscProps { // should be given nowDate too??\n  dateProfile: DateProfile\n  date: DateMarker\n  todayRange: DateRange\n  extraHookProps?: any\n}\n\nclass TimeColMisc extends BaseComponent<TimeColMiscProps> {\n\n  render() {\n    let { props } = this\n\n    return (\n      <DayCellContent date={props.date} dateProfile={props.dateProfile} todayRange={props.todayRange} extraHookProps={props.extraHookProps}>\n        {(innerElRef, innerContent) => (\n          innerContent &&\n            <div className='fc-timegrid-col-misc' ref={innerElRef}>{innerContent}</div>\n        )}\n      </DayCellContent>\n    )\n  }\n}\n","import {\n  createElement, VNode,\n  BaseComponent,\n  EventSegUiInteractionState,\n  CssDimValue,\n  DateMarker,\n  RefMap,\n  createRef,\n  PositionCache,\n  memoize,\n  DateRange,\n  NowIndicatorRoot,\n  DateProfile\n} from '@fullcalendar/common'\nimport { TableCellModel } from '@fullcalendar/daygrid' // TODO: good to use this interface?\nimport { TimeColsSeg, splitSegsByCol, splitInteractionByCol } from './TimeColsSeg'\nimport { TimeColsSlatsCoords } from './TimeColsSlatsCoords'\nimport { TimeCol } from './TimeCol'\n\n\nexport interface TimeColsContentProps {\n  axis: boolean\n  cells: TableCellModel[]\n  dateProfile: DateProfile\n  nowDate: DateMarker\n  todayRange: DateRange\n  businessHourSegs: TimeColsSeg[]\n  bgEventSegs: TimeColsSeg[]\n  fgEventSegs: TimeColsSeg[]\n  dateSelectionSegs: TimeColsSeg[]\n  eventSelection: string\n  eventDrag: EventSegUiInteractionState | null\n  eventResize: EventSegUiInteractionState | null\n  nowIndicatorSegs: TimeColsSeg[]\n  clientWidth: number | null\n  tableMinWidth: CssDimValue\n  tableColGroupNode: VNode\n  slatCoords: TimeColsSlatsCoords\n  onColCoords?: (colCoords: PositionCache) => void\n  forPrint: boolean\n}\n\n\nexport class TimeColsContent extends BaseComponent<TimeColsContentProps> { // TODO: rename\n\n  private splitFgEventSegs = memoize(splitSegsByCol)\n  private splitBgEventSegs = memoize(splitSegsByCol)\n  private splitBusinessHourSegs = memoize(splitSegsByCol)\n  private splitNowIndicatorSegs = memoize(splitSegsByCol)\n  private splitDateSelectionSegs = memoize(splitSegsByCol)\n  private splitEventDrag = memoize(splitInteractionByCol)\n  private splitEventResize = memoize(splitInteractionByCol)\n  private rootElRef = createRef<HTMLDivElement>()\n  private cellElRefs = new RefMap<HTMLTableCellElement>()\n\n\n  render() {\n    let { props, context } = this\n    let nowIndicatorTop =\n      context.options.nowIndicator &&\n      props.slatCoords &&\n      props.slatCoords.safeComputeTop(props.nowDate) // might return void\n\n    let colCnt = props.cells.length\n    let fgEventSegsByRow = this.splitFgEventSegs(props.fgEventSegs, colCnt)\n    let bgEventSegsByRow = this.splitBgEventSegs(props.bgEventSegs, colCnt)\n    let businessHourSegsByRow = this.splitBusinessHourSegs(props.businessHourSegs, colCnt)\n    let nowIndicatorSegsByRow = this.splitNowIndicatorSegs(props.nowIndicatorSegs, colCnt)\n    let dateSelectionSegsByRow = this.splitDateSelectionSegs(props.dateSelectionSegs, colCnt)\n    let eventDragByRow = this.splitEventDrag(props.eventDrag, colCnt)\n    let eventResizeByRow = this.splitEventResize(props.eventResize, colCnt)\n\n    return (\n      <div className='fc-timegrid-cols' ref={this.rootElRef}>\n        <table style={{\n          minWidth: props.tableMinWidth,\n          width: props.clientWidth\n        }}>\n          {props.tableColGroupNode}\n          <tbody>\n            <tr>\n              {props.axis &&\n                <td className='fc-timegrid-col fc-timegrid-axis'>\n                  <div className='fc-timegrid-col-frame'>\n                    <div className='fc-timegrid-now-indicator-container'>\n                      {typeof nowIndicatorTop === 'number' &&\n                        <NowIndicatorRoot isAxis={true} date={props.nowDate}>\n                          {(rootElRef, classNames, innerElRef, innerContent) => (\n                            <div\n                              ref={rootElRef}\n                              className={[ 'fc-timegrid-now-indicator-arrow' ].concat(classNames).join(' ')}\n                              style={{ top: nowIndicatorTop }}\n                            >{innerContent}</div>\n                          )}\n                        </NowIndicatorRoot>\n                      }\n                    </div>\n                  </div>\n                </td>\n              }\n              {props.cells.map((cell, i) => (\n                <TimeCol\n                  key={cell.key}\n                  elRef={this.cellElRefs.createRef(cell.key)}\n                  dateProfile={props.dateProfile}\n                  date={cell.date}\n                  nowDate={props.nowDate}\n                  todayRange={props.todayRange}\n                  extraHookProps={cell.extraHookProps}\n                  extraDataAttrs={cell.extraDataAttrs}\n                  extraClassNames={cell.extraClassNames}\n                  fgEventSegs={fgEventSegsByRow[i]}\n                  bgEventSegs={bgEventSegsByRow[i]}\n                  businessHourSegs={businessHourSegsByRow[i]}\n                  nowIndicatorSegs={nowIndicatorSegsByRow[i]}\n                  dateSelectionSegs={dateSelectionSegsByRow[i]}\n                  eventDrag={eventDragByRow[i]}\n                  eventResize={eventResizeByRow[i]}\n                  slatCoords={props.slatCoords}\n                  eventSelection={props.eventSelection}\n                  forPrint={props.forPrint}\n                />\n              ))}\n            </tr>\n          </tbody>\n        </table>\n      </div>\n    )\n  }\n\n\n  componentDidMount() {\n    this.updateCoords()\n  }\n\n\n  componentDidUpdate() {\n    this.updateCoords()\n  }\n\n\n  updateCoords() {\n    let { props } = this\n\n    if (\n      props.onColCoords &&\n      props.clientWidth !== null // means sizing has stabilized\n    ) {\n      props.onColCoords(\n        new PositionCache(\n          this.rootElRef.current,\n          collectCellEls(this.cellElRefs.currentMap, props.cells),\n          true, // horizontal\n          false\n        )\n      )\n    }\n  }\n\n}\n\n\nfunction collectCellEls(elMap: { [key: string]: HTMLElement }, cells: TableCellModel[]) {\n  return cells.map((cell) => elMap[cell.key])\n}\n","import {\n  createElement, VNode, Ref,\n  addDurations,\n  multiplyDuration,\n  wholeDivideDurations,\n  DateMarker,\n  BaseComponent,\n  EventSegUiInteractionState,\n  memoize,\n  CssDimValue,\n  PositionCache,\n  ScrollResponder,\n  ScrollRequest,\n  DateRange,\n  Duration,\n  DateProfile\n} from '@fullcalendar/common'\nimport { TableCellModel } from '@fullcalendar/daygrid' // TODO: good to use this interface?\nimport { TimeColsSlats, TimeSlatMeta } from './TimeColsSlats'\nimport { TimeColsContent } from './TimeColsContent'\nimport { TimeColsSlatsCoords } from './TimeColsSlatsCoords'\nimport { TimeColsSeg } from './TimeColsSeg'\n\n\nexport interface TimeColsProps {\n  cells: TableCellModel[]\n  dateProfile: DateProfile\n  slotDuration: Duration\n  nowDate: DateMarker\n  todayRange: DateRange\n  businessHourSegs: TimeColsSeg[]\n  bgEventSegs: TimeColsSeg[]\n  fgEventSegs: TimeColsSeg[]\n  dateSelectionSegs: TimeColsSeg[]\n  eventSelection: string\n  eventDrag: EventSegUiInteractionState | null\n  eventResize: EventSegUiInteractionState | null\n  rootElRef?: Ref<HTMLDivElement>\n  tableColGroupNode: VNode\n  tableMinWidth: CssDimValue\n  clientWidth: number | null\n  clientHeight: number | null\n  expandRows: boolean\n  nowIndicatorSegs: TimeColsSeg[]\n  onScrollTopRequest?: (scrollTop: number) => void\n  forPrint: boolean\n  axis: boolean\n  slatMetas: TimeSlatMeta[]\n  onSlatCoords?: (slatCoords: TimeColsSlatsCoords) => void\n}\n\ninterface TimeColsState {\n  slatCoords: TimeColsSlatsCoords | null\n}\n\n\n/* A component that renders one or more columns of vertical time slots\n----------------------------------------------------------------------------------------------------------------------*/\n\nexport class TimeCols extends BaseComponent<TimeColsProps, TimeColsState> {\n\n  private processSlotOptions = memoize(processSlotOptions)\n  private scrollResponder: ScrollResponder\n  private colCoords: PositionCache\n\n  state = {\n    slatCoords: null\n  }\n\n\n  render() {\n    let { props, state } = this\n\n    return (\n      <div className='fc-timegrid-body' ref={props.rootElRef} style={{\n        // these props are important to give this wrapper correct dimensions for interactions\n        // TODO: if we set it here, can we avoid giving to inner tables?\n        width: props.clientWidth,\n        minWidth: props.tableMinWidth\n      }}>\n        <TimeColsSlats\n          axis={props.axis}\n          dateProfile={props.dateProfile}\n          slatMetas={props.slatMetas}\n          clientWidth={props.clientWidth}\n          minHeight={props.expandRows ? props.clientHeight : ''}\n          tableMinWidth={props.tableMinWidth}\n          tableColGroupNode={props.axis ? props.tableColGroupNode : null /* axis depends on the colgroup's shrinking */}\n          onCoords={this.handleSlatCoords}\n        />\n        <TimeColsContent\n          cells={props.cells}\n          axis={props.axis}\n          dateProfile={props.dateProfile}\n          businessHourSegs={props.businessHourSegs}\n          bgEventSegs={props.bgEventSegs}\n          fgEventSegs={props.fgEventSegs}\n          dateSelectionSegs={props.dateSelectionSegs}\n          eventSelection={props.eventSelection}\n          eventDrag={props.eventDrag}\n          eventResize={props.eventResize}\n          todayRange={props.todayRange}\n          nowDate={props.nowDate}\n          nowIndicatorSegs={props.nowIndicatorSegs}\n          clientWidth={props.clientWidth}\n          tableMinWidth={props.tableMinWidth}\n          tableColGroupNode={props.tableColGroupNode}\n          slatCoords={state.slatCoords}\n          onColCoords={this.handleColCoords}\n          forPrint={props.forPrint}\n        />\n      </div>\n    )\n  }\n\n\n  componentDidMount() {\n    this.scrollResponder = this.context.createScrollResponder(this.handleScrollRequest)\n  }\n\n\n  componentDidUpdate(prevProps: TimeColsProps) {\n    this.scrollResponder.update(prevProps.dateProfile !== this.props.dateProfile)\n  }\n\n\n  componentWillUnmount() {\n    this.scrollResponder.detach()\n  }\n\n\n  handleScrollRequest = (request: ScrollRequest) => {\n    let { onScrollTopRequest } = this.props\n    let { slatCoords } = this.state\n\n    if (onScrollTopRequest && slatCoords) {\n\n      if (request.time) {\n        let top = slatCoords.computeTimeTop(request.time)\n        top = Math.ceil(top) // zoom can give weird floating-point values. rather scroll a little bit further\n        if (top) { top++ } // to overcome top border that slots beyond the first have. looks better\n\n        onScrollTopRequest(top)\n      }\n\n      return true\n    }\n  }\n\n\n  handleColCoords = (colCoords: PositionCache | null) => {\n    this.colCoords = colCoords\n  }\n\n\n  handleSlatCoords = (slatCoords: TimeColsSlatsCoords | null) => {\n    this.setState({ slatCoords })\n\n    if (this.props.onSlatCoords) {\n      this.props.onSlatCoords(slatCoords)\n    }\n  }\n\n\n  positionToHit(positionLeft, positionTop) {\n    let { dateEnv, options } = this.context\n    let { colCoords } = this\n    let { dateProfile } = this.props\n    let { slatCoords } = this.state\n    let { snapDuration, snapsPerSlot } = this.processSlotOptions(this.props.slotDuration, options.snapDuration)\n\n    let colIndex = colCoords.leftToIndex(positionLeft)\n    let slatIndex = slatCoords.positions.topToIndex(positionTop)\n\n    if (colIndex != null && slatIndex != null) {\n      let slatTop = slatCoords.positions.tops[slatIndex]\n      let slatHeight = slatCoords.positions.getHeight(slatIndex)\n      let partial = (positionTop - slatTop) / slatHeight // floating point number between 0 and 1\n      let localSnapIndex = Math.floor(partial * snapsPerSlot) // the snap # relative to start of slat\n      let snapIndex = slatIndex * snapsPerSlot + localSnapIndex\n\n      let dayDate = this.props.cells[colIndex].date\n      let time = addDurations(\n        dateProfile.slotMinTime,\n        multiplyDuration(snapDuration, snapIndex)\n      )\n\n      let start = dateEnv.add(dayDate, time)\n      let end = dateEnv.add(start, snapDuration)\n\n      return {\n        col: colIndex,\n        dateSpan: {\n          range: { start, end },\n          allDay: false\n        },\n        dayEl: colCoords.els[colIndex],\n        relativeRect: {\n          left: colCoords.lefts[colIndex],\n          right: colCoords.rights[colIndex],\n          top: slatTop,\n          bottom: slatTop + slatHeight\n        }\n      }\n    }\n  }\n\n}\n\n\nfunction processSlotOptions(slotDuration: Duration, snapDurationOverride: Duration | null) {\n  let snapDuration = snapDurationOverride || slotDuration\n  let snapsPerSlot = wholeDivideDurations(slotDuration, snapDuration)\n\n  if (snapsPerSlot === null) {\n    snapDuration = slotDuration\n    snapsPerSlot = 1\n    // TODO: say warning?\n  }\n\n  return { snapDuration, snapsPerSlot }\n}\n","import {\n  createElement, createRef, VNode,\n  DateComponent,\n  DateProfile,\n  EventStore,\n  EventUiHash,\n  EventInteractionState,\n  DateSpan,\n  memoize,\n  intersectRanges, DateRange,\n  DayTableModel,\n  DateEnv,\n  DateMarker,\n  Slicer,\n  Hit,\n  NowTimer,\n  CssDimValue,\n  Duration\n} from '@fullcalendar/common'\nimport { TimeColsSeg } from './TimeColsSeg'\nimport { TimeCols } from './TimeCols'\nimport { TimeSlatMeta } from './TimeColsSlats'\nimport { TimeColsSlatsCoords } from './TimeColsSlatsCoords'\n\n\nexport interface DayTimeColsProps {\n  dateProfile: DateProfile\n  dayTableModel: DayTableModel\n  axis: boolean\n  slotDuration: Duration\n  slatMetas: TimeSlatMeta[]\n  businessHours: EventStore\n  eventStore: EventStore\n  eventUiBases: EventUiHash\n  dateSelection: DateSpan | null\n  eventSelection: string\n  eventDrag: EventInteractionState | null\n  eventResize: EventInteractionState | null\n  tableColGroupNode: VNode\n  tableMinWidth: CssDimValue\n  clientWidth: number | null\n  clientHeight: number | null\n  expandRows: boolean\n  onScrollTopRequest?: (scrollTop: number) => void\n  forPrint: boolean\n  onSlatCoords?: (slatCoords: TimeColsSlatsCoords) => void\n}\n\n\nexport class DayTimeCols extends DateComponent<DayTimeColsProps> {\n\n  private buildDayRanges = memoize(buildDayRanges)\n  private slicer = new DayTimeColsSlicer()\n  private timeColsRef = createRef<TimeCols>()\n\n\n  render() {\n    let { props, context } = this\n    let { dateProfile, dayTableModel } = props\n\n    let isNowIndicator = context.options.nowIndicator\n    let dayRanges = this.buildDayRanges(dayTableModel, dateProfile, context.dateEnv)\n\n    // give it the first row of cells\n    // TODO: would move this further down hierarchy, but sliceNowDate needs it\n    return (\n      <NowTimer unit={isNowIndicator ? 'minute' : 'day'}>\n        {(nowDate: DateMarker, todayRange: DateRange) => (\n          <TimeCols\n            ref={this.timeColsRef}\n            rootElRef={this.handleRootEl}\n            {...this.slicer.sliceProps(props, dateProfile, null, context, dayRanges)}\n            forPrint={props.forPrint}\n            axis={props.axis}\n            dateProfile={dateProfile}\n            slatMetas={props.slatMetas}\n            slotDuration={props.slotDuration}\n            cells={dayTableModel.cells[0]}\n            tableColGroupNode={props.tableColGroupNode}\n            tableMinWidth={props.tableMinWidth}\n            clientWidth={props.clientWidth}\n            clientHeight={props.clientHeight}\n            expandRows={props.expandRows}\n            nowDate={nowDate}\n            nowIndicatorSegs={isNowIndicator && this.slicer.sliceNowDate(nowDate, context, dayRanges)}\n            todayRange={todayRange}\n            onScrollTopRequest={props.onScrollTopRequest}\n            onSlatCoords={props.onSlatCoords}\n          />\n        )}\n      </NowTimer>\n    )\n  }\n\n\n  handleRootEl = (rootEl: HTMLDivElement | null) => {\n    if (rootEl) {\n      this.context.registerInteractiveComponent(this, { el: rootEl })\n    } else {\n      this.context.unregisterInteractiveComponent(this)\n    }\n  }\n\n\n  queryHit(positionLeft: number, positionTop: number): Hit {\n    let rawHit = this.timeColsRef.current.positionToHit(positionLeft, positionTop)\n\n    if (rawHit) {\n      return {\n        component: this,\n        dateSpan: rawHit.dateSpan,\n        dayEl: rawHit.dayEl,\n        rect: {\n          left: rawHit.relativeRect.left,\n          right: rawHit.relativeRect.right,\n          top: rawHit.relativeRect.top,\n          bottom: rawHit.relativeRect.bottom\n        },\n        layer: 0\n      }\n    }\n  }\n\n}\n\n\nexport function buildDayRanges(dayTableModel: DayTableModel, dateProfile: DateProfile, dateEnv: DateEnv): DateRange[] {\n  let ranges: DateRange[] = []\n\n  for (let date of dayTableModel.headerDates) {\n    ranges.push({\n      start: dateEnv.add(date, dateProfile.slotMinTime),\n      end: dateEnv.add(date, dateProfile.slotMaxTime)\n    })\n  }\n\n  return ranges\n}\n\n\nexport class DayTimeColsSlicer extends Slicer<TimeColsSeg, [DateRange[]]> {\n\n  sliceRange(range: DateRange, dayRanges: DateRange[]): TimeColsSeg[] {\n    let segs: TimeColsSeg[] = []\n\n    for (let col = 0; col < dayRanges.length; col++) {\n      let segRange = intersectRanges(range, dayRanges[col])\n\n      if (segRange) {\n        segs.push({\n          start: segRange.start,\n          end: segRange.end,\n          isStart: segRange.start.valueOf() === range.start.valueOf(),\n          isEnd: segRange.end.valueOf() === range.end.valueOf(),\n          col\n        })\n      }\n    }\n\n    return segs\n  }\n\n}\n","import {\n  createElement,\n  DateProfileGenerator, DateProfile,\n  DayHeader,\n  DaySeriesModel,\n  DayTableModel,\n  memoize,\n  ChunkContentCallbackArgs\n} from '@fullcalendar/common'\nimport { DayTable } from '@fullcalendar/daygrid'\nimport { TimeColsView } from './TimeColsView'\nimport { DayTimeCols } from './DayTimeCols'\nimport { buildSlatMetas } from './TimeColsSlats'\n\n\nexport class DayTimeColsView extends TimeColsView {\n\n  private buildTimeColsModel = memoize(buildTimeColsModel)\n  private buildSlatMetas = memoize(buildSlatMetas)\n\n\n  render() {\n    let { options, dateEnv, dateProfileGenerator } = this.context\n    let { props } = this\n    let { dateProfile } = props\n    let dayTableModel = this.buildTimeColsModel(dateProfile, dateProfileGenerator)\n    let splitProps = this.allDaySplitter.splitProps(props)\n    let slatMetas = this.buildSlatMetas(dateProfile.slotMinTime, dateProfile.slotMaxTime, options.slotLabelInterval, options.slotDuration, dateEnv)\n    let { dayMinWidth } = options\n    let hasAttachedAxis = !dayMinWidth\n    let hasDetachedAxis = dayMinWidth\n\n    let headerContent = options.dayHeaders &&\n      <DayHeader\n        dates={dayTableModel.headerDates}\n        dateProfile={dateProfile}\n        datesRepDistinctDays={true}\n        renderIntro={hasAttachedAxis ? this.renderHeadAxis : null}\n      />\n\n    let allDayContent = (options.allDaySlot !== false) && ((contentArg: ChunkContentCallbackArgs) => (\n      <DayTable\n        {...splitProps['allDay']}\n        dateProfile={dateProfile}\n        dayTableModel={dayTableModel}\n        nextDayThreshold={options.nextDayThreshold}\n        tableMinWidth={contentArg.tableMinWidth}\n        colGroupNode={contentArg.tableColGroupNode}\n        renderRowIntro={hasAttachedAxis ? this.renderTableRowAxis : null}\n        showWeekNumbers={false}\n        expandRows={false}\n        headerAlignElRef={this.headerElRef}\n        clientWidth={contentArg.clientWidth}\n        clientHeight={contentArg.clientHeight}\n        forPrint={props.forPrint}\n        {...this.getAllDayMaxEventProps()}\n      />\n    ))\n\n    let timeGridContent = (contentArg: ChunkContentCallbackArgs) => (\n      <DayTimeCols\n        {...splitProps['timed']}\n        dayTableModel={dayTableModel}\n        dateProfile={dateProfile}\n        axis={hasAttachedAxis}\n        slotDuration={options.slotDuration}\n        slatMetas={slatMetas}\n        forPrint={props.forPrint}\n        tableColGroupNode={contentArg.tableColGroupNode}\n        tableMinWidth={contentArg.tableMinWidth}\n        clientWidth={contentArg.clientWidth}\n        clientHeight={contentArg.clientHeight}\n        onSlatCoords={this.handleSlatCoords}\n        expandRows={contentArg.expandRows}\n        onScrollTopRequest={this.handleScrollTopRequest}\n      />\n    )\n\n    return hasDetachedAxis\n      ? this.renderHScrollLayout(headerContent, allDayContent, timeGridContent, dayTableModel.colCnt, dayMinWidth, slatMetas, this.state.slatCoords)\n      : this.renderSimpleLayout(headerContent, allDayContent, timeGridContent)\n  }\n\n}\n\n\nexport function buildTimeColsModel(dateProfile: DateProfile, dateProfileGenerator: DateProfileGenerator) {\n  let daySeries = new DaySeriesModel(dateProfile.renderRange, dateProfileGenerator)\n\n  return new DayTableModel(daySeries, false)\n}\n","\nexport const OPTION_REFINERS = {\n  allDaySlot: Boolean\n}\n","import { createPlugin } from '@fullcalendar/common'\nimport { TimeColsView } from './TimeColsView'\nimport { DayTimeColsView, buildTimeColsModel } from './DayTimeColsView'\nimport { TimeColsSeg } from './TimeColsSeg'\nimport { DayTimeCols, DayTimeColsSlicer, buildDayRanges } from './DayTimeCols'\nimport { OPTION_REFINERS } from './options'\nimport './options-declare'\nimport './main.css'\n\nexport { DayTimeCols, DayTimeColsView, TimeColsView, buildTimeColsModel, buildDayRanges, DayTimeColsSlicer, TimeColsSeg }\nexport { TimeCols } from './TimeCols'\nexport { TimeSlatMeta, buildSlatMetas } from './TimeColsSlats'\nexport { TimeColsSlatsCoords } from './TimeColsSlatsCoords'\n\nexport default createPlugin({\n  initialView: 'timeGridWeek',\n  optionRefiners: OPTION_REFINERS,\n  views: {\n\n    timeGrid: {\n      component: DayTimeColsView,\n      usesMinMaxTime: true, // indicates that slotMinTime/slotMaxTime affects rendering\n      allDaySlot: true,\n      slotDuration: '00:30:00',\n      slotEventOverlap: true // a bad name. confused with overlap/constraint system\n    },\n\n    timeGridDay: {\n      type: 'timeGrid',\n      duration: { days: 1 }\n    },\n\n    timeGridWeek: {\n      type: 'timeGrid',\n      duration: { weeks: 1 }\n    }\n\n  }\n})\n"]},"metadata":{},"sourceType":"module"}